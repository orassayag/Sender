//module.exports = new EnumUtils();
//module.exports = new EnumUtils();
/* const enumUtils = new EnumUtils();
module.exports = enumUtils; */

/* EmailAddressStatusKeys, */
/* EmailAddressStatusKeys,  */
/* const { EmailAddressStatus, EmailAddressType, SendEmailStepName, SendGridReason } = require('./files/emailAddress.enum');
const { Placeholder } = require('./files/placeholder.enum');
const { EmailAddressesSourceType } = require('./files/sources.enum');
const { Mode, Status, Method } = require('./files/system.enum');
const { StatusIcon, Color, ColorCode } = require('./files/text.enum');

	// Check which parameters are used in Mongo database setup. Not all of them in use.

const createEnum = (mapItems) => {
    if (!mapItems || mapItems.length <= 0) {
        throw new Error(`No array received: ${mapItems} (1000000)`);
    }
    const mapList = new Map([...mapItems]);
    const symbolMap = {};
    mapList.forEach((value, key) => { symbolMap[key] = value; });
    return Object.freeze(symbolMap);
};

module.exports = {
    Color: createEnum(Color),
    ColorCode: createEnum(ColorCode),
    EmailAddressStatus: createEnum(EmailAddressStatus),
    EmailAddressType: createEnum(EmailAddressType),
    EmailAddressesSourceType: createEnum(EmailAddressesSourceType),
    Method: createEnum(Method),
    Mode: createEnum(Mode),
    Placeholder: createEnum(Placeholder),
    SendEmailStepName: createEnum(SendEmailStepName),
    Status: createEnum(Status),
    StatusIcon: createEnum(StatusIcon),
    SendGridReason: createEnum(SendGridReason)
}; */
/* const enumUtils = require('./enum.utils'); */
/* const { SourceType } = require('./files/templates.enum'); */
/* SourceType,  */
/* const Color
const ColorCode
const EmailAddressStatus
const EmailAddressType
const EmailAddressesSourceType
const Method
const Mode
const Placeholder
const Status
const StatusIcon */

/* EmailAddressStatusKeys, */
/* console.log(EmailAddressStatusKeys); */
//    ['NOT_EXPECTED_FIELD', 'notExpectedFIELD']
/* const EmailAddressStatus = [
    ['TOTAL', 'total'],
    ['PENDING', 'pending'],
    ['SENT', 'sent'],
    ['ERROR', 'error'],
    ['EXISTS', 'exists'],
    ['DATABASE', 'database'],
    ['SAVED', 'saved'],
    ['INVALID', 'invalid'],
    ['DUPLICATE', 'duplicate'],
    ['FILTER', 'filter'],
    ['SKIP', 'skip'],
    ['UNSAVE', 'sent'],
    ['IDENTICAL_ADDRESSES', 'identicalAddresses'],
    ['MONITOR_SENT', 'monitorSent'],
    ['SECURITY_ERROR', 'securityError'],
    ['SECURITY_EXISTS', 'securityExists'],
    ['MISSING_FIELD', 'missingField'],
    ['INVALID_STATUS', 'invalidStatus']
];

const EmailAddressType = [
    ['STANDARD', 'standard'],
    ['MONITOR', 'monitor']
];

const SendEmailStepName = [
    ['INITIATE', 'initiate'],
    ['VALIDATE', 'validate'],
    ['SEND', 'send'],
    ['FINALIZE', 'finalize']
];

const SendGridReason = [
    ['OK', 'OK'],
    ['ACCEPTED', 'ACCEPTED'],
    ['BAD_REQUEST', 'BAD REQUEST'],
    ['UNAUTHORIZED', 'UNAUTHORIZED'],
    ['FORBIDDEN', 'FORBIDDEN'],
    ['NOT_FOUND', 'NOT FOUND'],
    ['METHOD_NOT_ALLOWED', 'METHOD NOT ALLOWED'],
    ['PAYLOAD_TOO_LARGE', 'PAYLOAD TOO LARGE'],
    ['UNSUPPORTED_MEDIA_TYPE', 'UNSUPPORTED MEDIA TYPE'],
    ['TOO_MANY_REQUESTS', 'TOO MANY REQUESTS'],
    ['SERVER_UNAVAILABLE', 'SERVER UNAVAILABLE'],
    ['SERVICE_NOT_AVAILABLE', 'SERVICE NOT AVAILABLE']
];

module.exports = { EmailAddressStatus, EmailAddressType, SendEmailStepName, SendGridReason }; */

/* 2xx	2xx responses indicate a successful request	The request that you made is valid and successful.
200	OK	Your message is valid, but it is not queued to be delivered. †
202	ACCEPTED	Your message is both valid, and queued to be delivered.
4xx	4xx responses indicate an error with the request	There was a problem with your request.
400	BAD REQUEST
401	UNAUTHORIZED	You do not have authorization to make the request.
403	FORBIDDEN
404	NOT FOUND	The resource you tried to locate could not be found or does not exist.
405	METHOD NOT ALLOWED
413	PAYLOAD TOO LARGE	The JSON payload you have included in your request is too large.
415	UNSUPPORTED MEDIA TYPE
429	TOO MANY REQUESTS	The number of requests you have made exceeds SendGrid’s rate limitations
5xx	5xx responses indicate an error made by SendGrid	An error occurred when SendGrid attempted to processes it.
500	SERVER UNAVAILABLE	An error occurred on a SendGrid server.
503	SERVICE NOT AVAILABLE	The SendGrid v3 Web API is not available. */

/* const enumUtils = require('../enum.utils');

const EmailAddressStatus = enumUtils.createEnum([
    ['TOTAL', 'total'],
    ['PENDING', 'pending'],
    ['SENT', 'sent'],
    ['ERROR', 'error'],
    ['EXISTS', 'exists'],
    ['DATABASE', 'database'],
    ['SAVED', 'saved'],
    ['INVALID', 'invalid'],
    ['DUPLICATE', 'duplicate'],
    ['FILTER', 'filter'],
    ['SKIP', 'skip'],
    ['UNSAVE', 'sent'],
    ['IDENTICAL_ADDRESSES', 'identicalAddresses'],
    ['MONITOR_SENT', 'monitorSent'],
    ['SECURITY_ERROR', 'securityError'],
    ['SECURITY_EXISTS', 'securityExists'],
    ['MISSING_FIELD', 'missingField'],
    ['INVALID_STATUS', 'invalidStatus']
]);

const EmailAddressType = enumUtils.createEnum([
    ['STANDARD', 'standard'],
    ['MONITOR', 'monitor']
]);

const SendEmailStepName = enumUtils.createEnum([
    ['INITIATE', 'initiate'],
    ['VALIDATE', 'validate'],
    ['SEND', 'send'],
    ['FINALIZE', 'finalize']
]);

module.exports = { EmailAddressStatus, EmailAddressType, SendEmailStepName }; */
/* Validate
Send
Finalize */

/* this.totalCount = 0;
this.pendingCount = 0;
this.sentCount = 0;
this.errorCount = 0;
this.existsCount = 0;
this.databaseCount = 0;
this.savedCount = 0;
this.invalidCount = 0;
this.duplicateCount = 0;
this.filterCount = 0;
this.skipCount = 0;
this.unsaveCount = 0;
this.identicalCount = 0;
this.monitorSentCount = 0;
this.securityErrorCount = 0;
this.securityExistsCount = 0; */

/* const SaveStatus = enumUtils.createEnum([
    ['SAVE', 'save'],
    ['EXISTS', 'exists'],
    ['ERROR', 'error']
]); */
/* SaveStatus,  */
/* ===[PROCESS] Total: 319 | Sent: ✅  100 | Error: ❌ 23 | Exists: 11 | Invalid: 0 | Duplicates: 1===
===[PROCESS] Filter: 22 | Skip: 12 | Unsave: 2 | Monitor Sent: true/false=== */
/* SaveStatus,  */


/* const Placeholder = [
    ['DATE', '#DATE#']
];

module.exports = { Placeholder }; */

/* const enumUtils = require('../enum.utils');

const Placeholder = enumUtils.createEnum([
    ['DATE', '#DATE#']
]);

module.exports = { Placeholder }; */

/* const EmailAddressesSourceType = [
    ['DIRECTORY', 'directory'],
    ['FILE', 'file'],
    ['ARRAY', 'array']
];

module.exports = { EmailAddressesSourceType }; */

/* const enumUtils = require('../enum.utils');

const EmailAddressesSourceType = enumUtils.createEnum([
    ['DIRECTORY', 'directory'],
    ['FILE', 'file'],
    ['ARRAY', 'array']
]);

module.exports = { EmailAddressesSourceType }; */
//FOLDER/FILE/ARRAY

    //LIMIT EXCEEDED / SEND-ERROR-IN-A-ROW / SAVE-ERROR-IN-A-ROW
/* const Mode = [
    ['PRODUCTION', 'PRODUCTION'],
    ['DEVELOPMENT', 'DEVELOPMENT']
];

const Status = [
    ['INITIATE', 'INITIATE'],
    ['SEND', 'SEND'],
    ['PAUSE', 'PAUSE'],
    ['FINISH', 'FINISH']
];

const Method = [
    ['STANDARD', 'standard'],
    ['RANDOM_EXCEEDED', 'random_exceeded']
];

module.exports = { Mode, Status, Method }; */

/* const enumUtils = require('../enum.utils');

const Mode = enumUtils.createEnum([
    ['PRODUCTION', 'PRODUCTION'],
    ['DEVELOPMENT', 'DEVELOPMENT']
]);

const Status = enumUtils.createEnum([
    ['INITIATE', 'INITIATE'],
    ['SEND', 'SEND'],
    ['PAUSE', 'PAUSE'],
    ['FINISH', 'FINISH']
]);

const Method = enumUtils.createEnum([
    ['STANDARD', 'standard'],
    ['RANDOM_EXCEEDED', 'random_exceeded']
]);

module.exports = { Mode, Status, Method }; */

/* , BackupType */
/* const BackupType = enumUtils.createEnum([
    ['STANDARD', 'STANDARD'],
    ['SECONDARY', 'Secondary']
]); */

/* // This enum define the possible status icons.
const StatusIcon = [
    ['V', '✅'],
    ['X', '❌']
];

// This enum define the possible colors.
const Color = [
    ['BLACK', 'Black'],
    ['RED', 'Red'],
    ['GREEN', 'Green'],
    ['YELLOW', 'Yellow'],
    ['BLUE', 'Blue'],
    ['MAGENTA', 'Magenta'],
    ['CYAN', 'Cyan'],
    ['WHITE', 'White']
];

// This enum define the possible color codes.
const ColorCode = [
    ['Reset', '\x1b[0m'],
    ['Bright', '\x1b[1m'],
    ['Dim', '\x1b[2m'],
    ['Underscore', '\x1b[4m'],
    ['Blink', '\x1b[5m'],
    ['Reverse', '\x1b[7m'],
    ['Hidden', '\x1b[8m'],
    ['FgBlack', '\x1b[30m'],
    ['FgRed', '\x1b[31m'],
    ['FgGreen', '\x1b[32m'],
    ['FgYellow', '\x1b[33m'],
    ['FgBlue', '\x1b[34m'],
    ['FgMagenta', '\x1b[35m'],
    ['FgCyan', '\x1b[36m'],
    ['FgWhite', '\x1b[37m'],
    ['BgBlack', '\x1b[40m'],
    ['BgRed', '\x1b[41m'],
    ['BgGreen', '\x1b[42m'],
    ['BgYellow', '\x1b[43m'],
    ['BgBlue', '\x1b[44m'],
    ['BgMagenta', '\x1b[45m'],
    ['BgCyan', '\x1b[46m'],
    ['BgWhite', '\x1b[47m']
];

module.exports = { StatusIcon, Color, ColorCode }; */

/* const enumUtils = require('../enum.utils');

// This enum define the possible status icons.
const StatusIcon = enumUtils.createEnum([
    ['V', '✅'],
    ['X', '❌']
]);

// This enum define the possible colors.
const Color = enumUtils.createEnum([
    ['BLACK', 'Black'],
    ['RED', 'Red'],
    ['GREEN', 'Green'],
    ['YELLOW', 'Yellow'],
    ['BLUE', 'Blue'],
    ['MAGENTA', 'Magenta'],
    ['CYAN', 'Cyan'],
    ['WHITE', 'White']
]);

// This enum define the possible color codes.
const ColorCode = enumUtils.createEnum([
    ['Reset', '\x1b[0m'],
    ['Bright', '\x1b[1m'],
    ['Dim', '\x1b[2m'],
    ['Underscore', '\x1b[4m'],
    ['Blink', '\x1b[5m'],
    ['Reverse', '\x1b[7m'],
    ['Hidden', '\x1b[8m'],
    ['FgBlack', '\x1b[30m'],
    ['FgRed', '\x1b[31m'],
    ['FgGreen', '\x1b[32m'],
    ['FgYellow', '\x1b[33m'],
    ['FgBlue', '\x1b[34m'],
    ['FgMagenta', '\x1b[35m'],
    ['FgCyan', '\x1b[36m'],
    ['FgWhite', '\x1b[37m'],
    ['BgBlack', '\x1b[40m'],
    ['BgRed', '\x1b[41m'],
    ['BgGreen', '\x1b[42m'],
    ['BgYellow', '\x1b[43m'],
    ['BgBlue', '\x1b[44m'],
    ['BgMagenta', '\x1b[45m'],
    ['BgCyan', '\x1b[46m'],
    ['BgWhite', '\x1b[47m']
]);

module.exports = { StatusIcon, Color, ColorCode }; */

//    TitleData
//const TitleData = require('./files/TitleData');
/* , TextData */
///* const TextData = require('./files/TextData'); */
//SendEmailInitiateResult,
/* const SendEmailInitiateResult = require('./files/SendEmailInitiateResult'); */

/* 	setSendStart() {
		this.startDateTime = new Date();
	} */

    /* SECONDARY_BACKUP_PATH,  */
/* IS_CREATE_STANDARD_BACKUP, IS_CREATE_SECONDARY_BACKUP, */
/* 		this.isCreateStandardBackup = IS_CREATE_STANDARD_BACKUP;
		this.isCreateSecondaryBackup = IS_CREATE_SECONDARY_BACKUP; */
///* 		this.secondaryBackupPath = SECONDARY_BACKUP_PATH; */

/* MILLISECONDS_DELAY_MONGO_DATABASE_SYNC_COUNT,  */
/* MILLISECONDS_DELAY_MONGO_DATABASE_SYNC_COUNT, */
/* 		this.millisecondsDelayMongoDatabaseSyncCount = MILLISECONDS_DELAY_MONGO_DATABASE_SYNC_COUNT; */

        //this.resultDetails = null;
//        this.isSaved = false;
/*         this.error = null; */
/*         this.textFirstLine = null; */
//const { EmailAddressStatus } = require('../../../enums/files/emailAddress.enum');
/*         this.isMonitorEmail = false; */


/*     const pathToAttachment = `C:\\Or\\OrWorld\\Billy Ravid \\CV\\12102020\\CV Billy Ravid.doc`;
    const attachment = fs.readFileSync(pathToAttachment).toString('base64');
    const msg = {
      to: 'yardenushpozot@gmail.com',
      from: list[i].address,
      subject:
      text:
      attachments: [
        {
          content: attachment,
          filename: 'CV Billy Ravid.doc',
          type: 'application/doc',
          disposition: 'attachment'
        }
      ]
    }; */

    /*
const { isContinueProcess, exitProgramStatus } = data;
this.isContinueProcess = isContinueProcess;
this.exitProgramStatus = exitProgramStatus; */

//        this.isContinueProcess = true;
/* return {
    status: status,
    description: description,
    isContinueProcess: status === EmailAddressStatus.SAVE
}; */

/*     constructor() {
        this.sendError = null;
        this.code = null;
        this.reason = null;
        this.description = null;
        this.isSent = null;
    } */

/* */
//const SendGridCode = require('./')
/*             this.description = description;
            this.isSent = isSent;  } = data;
        let isSend = true;
        let sendError = null;
        let result = null; */

        /* this.totalCount = 0;
this.totalPendingCount = 0;
this.pendingCount = 0;
this.sentCount = 0;
this.errorCount = 0;
this.existsCount = 0;
this.databaseCount = 0;
this.saveCount = 0;
this.invalidCount = 0;
this.duplicateCount = 0;
this.filterCount = 0;
this.skipCount = 0;
this.unsaveCount = 0;
this.identicalAddressesCount = 0;
this.monitorSentCount = 0;
this.securityErrorCount = 0;
this.securityExistsCount = 0;
this.missingFieldCount = 0;
this.invalidStatusCount = 0;
this.identicalStatusCount = 0;
this.notExpectedFieldCount = 0; */

		//this.savedCount = 0;
/*     ['TOTAL', 'total'],
	['PENDING', 'pending'],
	['SENT', 'sent'],
	['ERROR', 'error'],
	['EXISTS', 'exists'],
	['DATABASE', 'database'],
	['SAVED', 'saved'],
	['INVALID', 'invalid'],
	['DUPLICATE', 'duplicate'],
	['FILTER', 'filter'],
	['SKIP', 'skip'],
	['UNSAVE', 'sent'],
	['IDENTICAL_ADDRESSES', 'identicalAddresses'],
	['MONITOR_SENT', 'monitorSent'],
	['SECURITY_ERROR', 'securityError'],
	['SECURITY_EXISTS', 'securityExists'],
	['MISSING_FIELD', 'missingField'],
	['INVALID_STATUS', 'invalidStatus'] */

/* 			if (isAdd)
			{

			} */

/* 	const EmailAddressStatus = enumUtils.createEnum([
		['PENDING', 'pending'],
		['SAVED', 'saved'],
		['SENT', 'sent'],
		['ERROR', 'error'],
		['EXISTS', 'exists'],
		['INVALID', 'invalid'],
		['DUPLICATE', 'duplicate'],
		['FILTER', 'filter'],
		['SKIP', 'skip'],
		['UNSAVE', 'sent'],
		['IDENTICAL', 'identical'],
		['SECURITY_ERROR', 'securityError'],
		['SECURITY_EXISTS', 'securityExists']
	]); */

				//if (this.hasOwnProperty(myProp))
		//if(myObj.hasOwnProperty(myProp)){

/* 	===[PROCESS] Total: 1,412 | Pending: 500 | Sent: ✅  100 | Error: ❌ 23 | Exists: 11 | Datebase: 24,235===
===[PROCESS] Saved: 100 | Invalid: 0 | Duplicates: 1 | Filter: 22 | Skip: 12 | Unsave: 2 | Identical: 0===
===[PROCESS] Monitor: 1 | Security Error: 0=== */
/* this.saveCount = 0;
this.totalCount = 0;
this.databaseCount = 0;
this.existsCount = 0;
this.invalidCount = 0;
this.validFixCount = 0;
this.invalidFixCount = 0;
this.unsaveCount = 0;
this.filterCount = 0;
this.skipCount = 0; */
//activeSearchEngineNames
/* 	updateEmailAddressData(emailAddressesResult, searchEngineName) {
		const { saveCount, totalCount, existsCount, invalidCount, validFixCount,
			invalidFixCount, unsaveCount, filterCount, skipCount } = emailAddressesResult;
		// Update all the data.
		this.saveCount += saveCount;
		this.totalCount += totalCount;
		this.databaseCount += saveCount;
		this.existsCount += existsCount;
		this.invalidCount += invalidCount;
		this.validFixCount += validFixCount;
		this.invalidFixCount += invalidFixCount;
		this.unsaveCount += unsaveCount;
		this.filterCount += filterCount;
		this.skipCount += skipCount;
		this.statistics[searchEngineName] += saveCount;
	} */

    //const { Color } = require('../core/enums/files/text.enum');
/* const { BackupType } = require('../core/enums/files/system.enum'); */
//backupType
//${backupType}
/* backupType */
        /* backupType */
    /* backupType */
    //backupType
    //${backupType}
    /*     async setParameters(backupType) {
            logUtils.logMagentaStatus(`SET THE ${backupType} PARAMETERS`);
            let backupTemporaryPath = null;
            switch (backupType) {
                case BackupType.STANDARD:
                    for (let i = 0; i < this.backupData.backupMaximumDirectoryVersionsCount; i++) {
                        const backupName = textUtils.getBackupName({
                            applicationName: this.backupData.applicationName,
                            date: timeUtils.getDateNoSpaces(),
                            title: this.backupTitle,
                            index: i
                        });
                        backupTemporaryPath = pathUtils.getJoinPath({
                            targetPath: this.backupData.backupsPath,
                            targetName: textUtils.addBackslash(backupName)
                        });
                        if (!await fileUtils.isPathExists(backupTemporaryPath)) {
                            this.backupData.targetBackupName = backupName;
                            this.backupData.targetFullPath = backupTemporaryPath;
                            break;
                        }
                    }
                    break;
                case BackupType.SECONDARY:
                    this.backupData.targetBackupName = this.backupData.applicationName;
                    this.backupData.targetFullPath = this.backupData.secondaryBackupPath;
                    break;
            }
        } */
//backupType
//${backupType}
//${backupType}
/* backupType */
/*         if (this.backupData.isCreateStandardBackup) { */
/* BackupType.STANDARD */
/*         } */
/*         if (this.backupData.isCreateSecondaryBackup) {
            await this.create(BackupType.SECONDARY);
        } */


/*     constructor() {
        this.sendError = null;
        this.code = null;
        this.reason = null;
        this.description = null;
        this.isSent = null;
    } */

/* */
//const SendGridCode = require('./')
/*             this.description = description;
            this.isSent = isSent;  } = data;
        let isSend = true;
        let sendError = null;
        let result = null; */


/* class TemplateData {

	constructor(data) {
        const { title, text } = data;
        this.titleId = title.id,
        this.textId = text.id,
        this.title = title.title;
        this.titleDisplay = title.titleDisplay;
        this.text = text.text;
        this.textDisplay = text.textDisplay;
    }
}

module.exports = TemplateData; */
        //this.textFirstLine = text.textFirstLine;
/* titleId, textId,  */
//        this.textsList = textFirstLine;

/* class TitleData {

	constructor(data) {
        const { id, title, titleDisplay} = data;
        this.id = id;
        this.title = title;
        this.titleDisplay = titleDisplay;
    }
}

module.exports = TitleData; */

/*         const isConfirmed = await confirmationService.confirm(settings);
        if (!isConfirmed) {
            logUtils.logColorStatus({
                status: 'EXIT: ABORTED BY THE USER',
                color: Color.RED
            });
        } */
        //return isConfirmed;
                    //return false;
        //return true;
        //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSendEmailDelayCount);
                //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSendEmailDelayCount);
        //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSendEmailDelayCount);
        // One last log (maybe delay?).
/*         logService.logProgress({
            applicationData: this.applicationData,
            searchProcessData: this.searchProcessData
        }); */
/*     async validateInternetConnection() {
        if (!applicationService.applicationData.isProductionMode) {
            return;
        }
        logUtils.logMagentaStatus('VALIDATE INTERNET CONNECTION');
        await validationService.validateInternetConnection();
    }

    validateModeStatus() {
        // Check that the mode is PRODUCTION and both send and save emails flags marked as true.
        if (applicationService.applicationData.isProductionMode &&
            (!applicationService.applicationData.isSendEmails || !applicationService.applicationData.isSaveEmails)) {

        }
    } */

/*         // Validate internet connection.
await this.validateInternetConnection();
// Validate mode status.
this.validateModeStatus(); */

        //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSendEmailDelayCount);
                    //console.log(emailData);
        //console.log(sendEmailService.sendEmailsData);
            //debugger;
                //debugger;
            //debugger;
/*                 this.exit({
                    status: emailProcessResult.exitProgramStatus,
                    color: Color.RED
                }); */
            //}
        //const { status, color } = data;
/*         setTimeout(() => {
            console.log(this.emailsData.emailsList[0]);
        }, 60000); */
            //console.log(this.emailsData.emailsList[i]);
        //await this.pause();
        //console.log(countsLimitsService.countsLimitsData.millisecondsSendEmailDelayCount);
        //await systemUtils.pause(countsLimitsService.millisecondsSendEmailDelayCount);
//milliseconds
        //await new Promise(resolve => setTimeout(resolve, 5000));
/* const application = require('../core/models/application'); */
            //console.log(this.emailsData.emailsList[i]);
//        console.log(sendEmailService.sendEmailsData);
//        console.log(this.emailsData.emailsList);
//        console.log(this.emailsData.emailsList);
        //console.log(sendEmailService.sendEmailsData);
/*         for (let i = 0; i < 10; i++) {
            accountsService.checkAccount(true);
            if (i === 7) {
                console.log(accountsService.accountsData);
            }

        } */

/*          */

/*
const { ApplicationData, CountsLimitsData, MongoDatabaseData, LogsData,
    PathsData, SendEmailsData, SourcesData } = require('../core/models/application');
const { accountsService, createEmailsService, mongoDatabaseService, logService,
    templatesService, sendEmailService, validationService } = require('../services'); */

        //this.initiateSettings();
        //this.applicationData = null;
        //this.sendEmailsData = null;
        //this.countsLimitsData = null;
        //this.mongoDatabaseData = null;
        //this.pathsData = null;
        //this.logsData = null;
        //this.accountsData = null;
        //this.sourcesData = null;
                //this.templatesData = null;
                //this.emailsData = null; //initiateCreateEmailsService
/*         await this.initiateMongoDatabaseService();
await this.initiateLogService();
this.initiateAccountsService();
await this.initiateCreateEmailsService();
await this.initiateTemplatesService(); */


    //async initiateMongoDatabaseService() {
/*         await mongoDatabaseService.initiate({
            countsLimitsData: this.countsLimitsData,
            mongoDatabaseData: this.mongoDatabaseData
        });
        // Load all the previous existing email addresses from the Mongo database.
        this.sendEmailsData.addCounter('database', await mongoDatabaseService.getEmailAddressesCount()); */
    //}

    //async initiateLogService() {
/*         await logService.initiate({
            logsData: this.logsData,
            applicationData: this.applicationData,
            mongoDatabaseData: this.mongoDatabaseData,
            countsLimitsData: this.countsLimitsData,
            pathsData: this.pathsData
        }); */
    //}

/*     initiateAccountsService() {
        // Initiate the accounts service.
        // ===ACCOUNTS DATA=== //
        this.accountsData = accountsService.initiate();
    } */

    //async initiateCreateEmailsService() {
/*         const initiateResults = await createEmailsService.initiate({
            applicationData: this.applicationData,
            sourcesData: this.sourcesData,
            countsLimitsData: this.countsLimitsData,
            sendEmailsData: this.sendEmailsData
        });
        // Update all data after the initiate of createEmails service.
        const { applicationData, emailsData, sendEmailsData } = initiateResults;
        this.applicationData = applicationData,
            this.emailsData = emailsData,
            this.sendEmailsData = sendEmailsData; */
    //}

/*     async initiateTemplatesService() {
        //this.templatesData = await templatesService.initiate();
    } */


        // Initiate the Mongo database service.
//        // Initiate the log service.
        // Initiate the create emails service.
        // ===EMAILS DATA=== //
/*         // Initiate the templates service.
        // ===TEMPLATES DATA=== // */
/*     async startSend() {
        // Start the console status interval.
        this.sendInterval = setInterval(async () => {
            // Start the process for the first interval round.
            if (!this.applicationData.startDateTime) {
                this.applicationData.startDateTime = new Date();
                await this.startProcess();
            }
            // Update the current time of the process.
            const { time, minutes } = timeUtils.getDifferenceTimeBetweenDates({
                startDateTime: this.applicationData.startDateTime,
                endDateTime: new Date()
            });
            this.applicationData.time = time;
            this.applicationData.minutesCount = minutes; */
/*             // Log the status console each interval round.
            logService.logProgress({
                applicationData: this.applicationData,
                searchProcessData: this.searchProcessData
            }); */
/*         }, this.countsLimitsData.millisecondsIntervalCount);
    }

    async startProcess() {
        // Loop all the emails to send process and send them.
        for (let i = 0; i < this.emailsData.emailsList.length; i++) {
            await this.runEmailLogicInitiate(this.emailsData.emailsList[i]);
            // Do pause between each emails here.
        }
    } */

/*     async runEmailLogicInitiate(emailData) {
        const sendEmailInitiateResult = await sendEmailService.runEmailProcessInitiate({

        });
        // updated all data.
        if (!sendEmailInitiateResult.isContinueProcess) {
            return;
        }
    }
 */
    // Update counters if needed.
/*     checkEmailStatus(emailData) {
        let isContinueProcess = true;

        return isContinueProcess;
    } */

/* , EmailAddressStatus */
/*         if (!this.checkEmailStatus(emailData)) {
            return;
        } */
/*         let accountData = null;
        for (let i = 0; i < 10; i++) {
            const result = accountsService.checkAccount({
                isIncrement: false,
                accountData: accountData,
                accountsData: this.accountsData
            });
            accountData = result.accountData;
            this.accountsData = result.accountsData;
            if (result.isNoAccountsLeft) {
                break;
            }
            if (i === 3) {
                console.log(result);
                console.log(this.accountsData);
            }

        } */
    //            debugger;
/*         console.log(accountData);
        console.log(this.accountsData); */

/*         const emailData = this.emailsData.emailsList.find(e => e.status === 'pending');
        const sendEmailResult = await sendEmailService.runEmailProcess(emailData);
        console.log(sendEmailResult); */

/*     endProcesses(data) {
        const { exitReason, color, code } = data;
        if (this.sendInterval) {
            clearInterval(this.sendInterval);
        }
        this.applicationData.status = Status.FINISH;
        logService.logProgress({
            applicationData: this.applicationData,
            searchProcessData: this.searchProcessData
        });
        systemUtils.exit(exitReason, color, code);
    } */

                        // Initiate the settings.
                // Initiate all the services.
                // Initiate the Mongo database service.
                // Initiate the log service.
                // Initiate the accounts service.
        // Initiate the create emails service.
                // Initiate the tempates service.
/*     initiateSettings() {
        logUtils.logMagentaStatus('INITIATE THE SETTINGS');
        // ===APPLICATION DATA=== //
        this.applicationData = new ApplicationData({
            settings: settings,
            status: Status.INITIATE
        });
        // ===SEND EMAILS DATA=== //
        this.sendEmailsData = new SendEmailsData();
        // ===LOGS=== //
        this.logsData = new LogsData(settings);
        // ===COUNTS & LIMITS DATA=== //
        this.countsLimitsData = new CountsLimitsData(settings);
        // ===PATHS DATA=== //
        this.pathsData = new PathsData(settings);
        // ===MONGO DATABASE DATA=== //
        this.mongoDatabaseData = new MongoDatabaseData(settings);
        // ===SOURCES DATA=== //
        this.sourcesData = new SourcesData(settings);
    } */

//const { Status } = require('../core/enums/files/system.enum');
//        console.log(this.accountsData);
        //console.log(this.sendEmailsData);
        //console.log(this.emailsData.emailsList.filter(e => e.status === 'skip'));
        //console.log(this.emailsData.emailsList.filter(e => e.type === 'monitor'));
                //this.applicationData.setSendStart();
        //console.log(this.emailsData.emailsList.filter(e => e.status === 'skip'));
                //console.log(this.emailsData);
/*         console.log(this.emailsData.emailsList.filter(e => e.type === 'monitor'));
        console.log(this.emailsData.emailsList.findIndex(e => e.type === 'monitor')); */
        //console.log(this.emailsData.emailsList.length);
//emailAddressesService,
/*         // Initiate the prepare emails service.
        this.initiatePrepareEmailsService(); */
/* prepareEmailsService, */
/*     initiatePrepareEmailsService() {
        // Initiate the prepare emails service.
        prepareEmailsService.initiate({
            applicationData: this.applicationData,
            countsLimitsData: this.countsLimitsData
        });
    } */
        // Prepare the emails before start to send them.
/*         this.emailsData = prepareEmailsService.prepareEmails(this.emailsData);
        console.log(this.emailsData.emailsList.filter(e => e.status === 'initiate')); */
        //prepareEmailsService.initiate(this.countsLimitsData);
/*     async startProcess() {
console.log('ok');
process.exit(1);
} */
        //console.log(this.emailsData);
/* AccountsData, */
/*         (async () => {
        await this.startProcess();
    })(); */
/*     async startProcess() {
        console.log('ok');
        process.exit(1);
    }
 */
/* validateEmailsService, */

//emailAddressesService
/* const prepareEmailsService = require('./files/prepareEmails.service'); */
/* prepareEmailsService, */
/* validateEmailsService,  */
/* emailsService,  */
/* const emailsService = require('./files/emails.service'); */

// Get number from settings.js - 100.
// Get number from settings.js - 100.
// Get number from settings.js - 100.
// Get number from settings.js - 100.
// Get number from settings.js - 100.
/* const accountsService = new AccountsService();
module.exports = accountsService; */
        //return this.isAccountsLeft();
        //return this.isAccountsLeft();
/*     isAccountsLeft() {
        return this.isAccountsLeft;
        //this.return this.accountData !== null && this.accountData !== undefined;
    } */
        //debugger;
//this.accountsData.isNoAccountsLeft =
/*     getAccount() {
        return this.accountsData.accountsList.find(a => a.sentCount < 3); // Get number from settings.js - 100.
    } */
                        //this.accountData = this.getAccount();
            //this.accountData = this.getAccount();
///*         this.isNoAccountsLeft = false; */
    //accountsData
/* data */
/*         const { isIncrement, accountData, accountsData } = data; */
    //let updatedAccountData = null;
/* accountsData */
    //updatedAccountData = this.getAccount(accountsData);
    //accountsData.activeAccount = updatedAccountData;
/*             return {
                isNoAccountsLeft: false,
                accountData: updatedAccountData,
                accountsData: accountsData
            }; */


/*         if (isIncrement) {
            this.accountData.sentCount++;
        }
        else { */
/*             return {
                isNoAccountsLeft: false,
                accountData: accountData,
                accountsData: accountsData
            }; */
    //}
    // updatedAccountData = { ...accountData };
    //updatedAccountData = this.getAccount(accountsData);
/*         accountsData.activeAccount = updatedAccountData;
return {
isNoAccountsLeft: updatedAccountData === null || updatedAccountData === undefined,
accountData: updatedAccountData,
accountsData: accountsData
}; */

        //return accountsData;

// =======================

/* const accounts = require('../../../misc/data/accounts/accounts');
const { AccountData, AccountsData } = require('../../core/models/application');
const { textUtils, validationUtils } = require('../../utils');

class AccountsService {

    constructor() {
        this.lastAccountDataId = 0;
    }

    initiate() {
        if (accounts.length <= 0) {
            throw new Error('No accounts found in the account.json file. (1000014)');
        }
        const accountsData = new AccountsData();
        for (let i = 0; i < accounts.length; i++) {
            const { username, APIKey } = accounts[i];
            this.validateAccount(username, APIKey, i);
            if (accountsData.accountsList.findIndex(a => a.emailAddress === username) > -1) {
                throw new Error(`Duplicate accounts detected with the username: ${username}. (1000014)`);
            }
            this.lastAccountDataId++;
            accountsData.accountsList.push(new AccountData({
                id: this.lastAccountDataId,
                username: username,
                APIKey: APIKey
            }));
        }
        return accountsData;
    }

    validateAccount(username, APIKey, i) {
        if (!username) {
            throw new Error(`Missing username of account index: ${i}. (1000014)`);
        }
        if (!validationUtils.validateEmailAddress(textUtils.toLowerCase(username))) {
            throw new Error(`Invalid username of account index: ${i}. (1000014)`);
        }
        if (!APIKey) {
            throw new Error(`Missing API key of account index: ${i}. (1000014)`);
        }
        if (!validationUtils.isValidSendGridAPIKey(APIKey)) {
            throw new Error(`Invalid API key of account index: ${i}. (1000014)`);
        }
    }

    getAccount(accountsData) {
        return accountsData.accountsList.find(a => a.sentCount < 3); // Get number from settings.js - 100.
    }

    checkAccount(data) {
        const { isIncrement, accountData, accountsData } = data;
        let updatedAccountData = null;
        if (!accountData) {
            updatedAccountData = this.getAccount(accountsData);
            accountsData.activeAccount = updatedAccountData;
            return {
                isNoAccountsLeft: false,
                accountData: updatedAccountData,
                accountsData: accountsData
            };
        }
        if (isIncrement) {
            accountData.sentCount++;
        }
        else {
            return {
                isNoAccountsLeft: false,
                accountData: accountData,
                accountsData: accountsData
            };
        }
        // Update exists account data in the accountsData list.
        const accountDataIndex = accountsData.accountsList.findIndex(a => a.id === accountData.id);
        if (accountDataIndex <= -1) {
            throw new Error(`Account id ${accountData.id} not exists in the accountsList (100034)`);
        }
        // Check if need to switch account due to the limit exceeded of send count per day.
        updatedAccountData = { ...accountData };
        if (accountData.sentCount <= 3) { // Get number from settings.js - 100.
            updatedAccountData = this.getAccount(accountsData);
        }
        accountsData.accountsList[accountDataIndex] = accountData;
        accountsData.activeAccount = updatedAccountData;
        return {
            isNoAccountsLeft: updatedAccountData === null || updatedAccountData === undefined,
            accountData: updatedAccountData,
            accountsData: accountsData
        };
    }
}

const accountsService = new AccountsService();
module.exports = accountsService; */
//            //accountData.sentCount--;

           // const isCommonDomain = commonEmailAddressDomainsList.findIndex(domain => domain.domain === domainPart) > -1;
            //if (isCommonDomain) {
/*         // No need to filter in DEVELOPMENT mode.
        if (!applicationService.applicationData.isProductionMode) {
            return emailData;
        } */
/* const createEmailsService = new CreateEmailsService();
module.exports = createEmailsService; */
        //debugger;
                //debugger;
        //console.log(returnList);
        //console.log(emailAddressesList);
/*     constructor(data) {
        const { id, emailAddress, type } = data;
        this.id = id;
        this.createDateTime = new Date();
        this.accountId = null;
        this.accountApiKey = null;
        this.toEmailAddress = emailAddress;
        this.fromEmailAddress = null;
        this.subjectId = null;
        this.subject = null;
        this.subjectDisplay = null;
        this.textId = null;
        this.text = null;
        this.textDisplay = null;
        this.status = EmailAddressStatus.PENDING;
        this.type = type;
        this.resultDateTime = null;
        this.resultDetails = null;
        this.resultCode = null;
        this.retriesCount = 0;
    } */
/*  + 1 */
    //debugger;

/*      this.applicationData = null;
        this.sourcesData = null;
        this.countsLimitsData = null;
        this.sendEmailsData = null; */
/* data */
/*         const { applicationData, sourcesData, countsLimitsData, sendEmailsData } = data;
        this.applicationData = applicationData;
        this.sourcesData = sourcesData;
        this.countsLimitsData = countsLimitsData;
        this.sendEmailsData = sendEmailsData; */
/*         return {
    applicationData: applicationService.applicationData,
    emailsData: emailsData,
    sendEmailsData: sendEmailService.sendEmailsData
}; */
                        //const sendEmailService = require('./sendEmail.service');

/*         sendEmailService.sendEmailsData.addCounter('pending', emailsData.emailsList.length);
sendEmailService.sendEmailsData.addCounter('database', await mongoDatabaseService.getEmailAddressesCount()); */

                //sendEmailService.sendEmailsData.addCounter('total', emailAddressesList.length);
            //sendEmailService.sendEmailsData.addCounter('total', total);
/*         const emailAddressesList = ['']; */
/*     // Validate if exceeded from the configured number,
    // take random email addresses from the list.
    validateRandomExceeded(emailAddressesList) {
        if (emailAddressesList.length <= countsLimitsService.countsLimitsData.maximumSendEmails) {
            // Update send emails data.
            this.updateSendEmailsData(emailAddressesList.length, emailAddressesList.length);
            return emailAddressesList;
        }
        const total = emailAddressesList.length;
        emailAddressesList = this.getRandomUniqueKeysFromArray({
            list: emailAddressesList,
            itemsCount: countsLimitsService.countsLimitsData.maximumSendEmails,
            isSkipLogic: false
        });
        const pending = emailAddressesList.length;
        // Update send emails data.
        this.updateSendEmailsData(total, pending);
        return emailAddressesList;
    } */

/*     updateSendEmailsData(total, pending) {
    if (!sendEmailService.sendEmailsData.totalCount) {
        applicationService.applicationData.method = total !== pending ? Method.RANDOM_EXCEEDED : Method.STANDARD;
        sendEmailService.sendEmailsData.addCounter('total', total);
    }
    sendEmailService.sendEmailsData.addCounter('pending', pending);
} */

/* const { EmailAddressesSourceType } = require('../../core/enums/files/sources.enum');
const { EmailAddressStatus, EmailAddressType } = require('../../core/enums/files/emailAddress.enum');
const { Method } = require('../../core/enums/files/system.enum'); */
/*         // Update sendEmailsData.
        this.updateSendEmailsData(emailsData.emailsList.length, emailsData.emailsList.length); */
//                debugger;
                //currentIndex -= 1;
                                //        let currentIndex = emailsData.emailsList.length, temporaryValue, randomIndex;
                                //emailsData.emailsList[randomIndex] = temporaryValue;
                                                //emailsData.emailsList[currentIndex] = emailsData.emailsList[randomIndex];
/*         emailData: emailData,
lowerEmailAddress: lowerEmailAddress,
existsEmailAddressesList: existsEmailAddressesList */
//            //let { emailsData } = data;
/*         if (isMonitorList) {
// If monitor place in random places + monitor status.
}
else {
for (let i = 0; i < emailAddressesList.length; i++) {
let emailData = new EmailData({
    emailAddress: emailAddressesList[i],
    type: EmailAddressType.STANDARD
});
emailData = this.validateEmail(emailData); */
/*                 emailsData.emailsList.push(new EmailData(emailAddressesList[i]));
                emailsData.emailsList[i] = this.validateEmail(emailsData.emailsList[i]); */
/*             }
        } */

/* , */
/*             isMonitorList: false */
/* , isMonitorList */
        //,
/*             isMonitorList: isMonitorList */
        //return this.createEmailsData(emailAddressesList);
/* ,
    isMonitorList: false */
                    //return this.createEmailsData(emailAddressesList);

/*         let validateCount = true; */
/*             isRandomPlace = false;
            validateCount */
/*                     isMonitorList: false */
/*         let targetPath = null; */
    //const { path, parameterName } = this.getPath();

/*     async createEmailsData(emailAddressesList) {
        // Create all the emails.
        let emailsData = this.createEmailsFromList({
            emailAddressesList: emailAddressesList,
            emailsData: [],
            isRandomPlace: false
        });
        // Validate random exceeded.
        //emailsData = this.validateRandomExceeded(emailsData);
        // Add monitor emails if needed.
        if (!applicationService.applicationData.isMonitorLogic) {
            emailsData = await this.addMonitorEmails(emailsData);
        }
        return emailsData;
    } */

    //,
/*             isMonitorList: true */

/*     createMonitorEmails(monitorEmailAddressesList)
    {
        const updatedmonitorEmailAddressesList = [];
        for(let i = 0; i < monitorEmailAddressesList.length; i++)
        {

        }
    }

    //        //this.validateEmailAddressesCount(emailAddressesList);

    async addMonitorEmails(emailsData) {
        const path = pathUtils.getJoinPath({
            targetPath: __dirname,
            targetName: '../../../misc/data/monitor/monitor.txt'
        });
        if (!fileUtils.isPathExists(path)) {
            throw new Error(`Invalid or no monitor.txt parameter was found: Excpected a number but received: ${path} (1000014)`);
        }
        if (fileUtils.isDirectoryPath(path)) {
            throw new Error(`The monitor.txt path is a directory but it's needs to be of a file: ${path} (1000014)`);
        }
        // Fetch the monitor email addresses.
        const monitorEmailAddressesList = await this.fetchEmailAddresses(path);
        this.validateEmailAddressesCount(monitorEmailAddressesList);
        // Create the monitor emails: validate and remove duplicates, and validate limit exceeded.
        return emailsData;
    } */

// ===============================

/* const { textUtils, validationUtils } = require('../../utils');
const { EmailAddressStatus } = require('../../core/enums/files/emailAddress.enum');
const { invalidDomains, filterEmailAddressDomains, filterEmailAddresses, commonEmailAddressDomainsList } = require('../../configurations/emailAddress.configuration');

class PrepareEmailsService {

    constructor() {
        applicationService.applicationData = null;
        countsLimitsService.countsLimitsData = null;
    }

    initiate(data) {
        const { applicationData, countsLimitsData } = data;
        applicationService.applicationData = applicationData;
        countsLimitsService.countsLimitsData = countsLimitsData;
    }

    prepareEmails(emailsData) {
        for (let i = 0; i < emailsData.emailsList.length; i++) {
            emailsData.emailsList[i] = this.prepareEmail(emailsData.emailsList[i]);
        }
        if (applicationService.applicationData.isSkipLogic) {
            // Check for skip domains.
            emailsData = this.skipDomains(emailsData);
        }
        return emailsData;
    }

    prepareEmail(email) {
        // Validate the email address.
        email = this.validateEmailAddress(email);
        // Filter the email address.
        email = this.filterEmailAddress(email);
        return email;
    }

    validateEmailAddress(email) {
        if (!validationUtils.validateEmailAddress(email.toEmailAddress)) {
            email.status = EmailAddressStatus.INVALID;
        }
        return email;
    }

    filterEmailAddress(email) {
        if (!email.status) {
            return email;
        }
        const domainPart = textUtils.getEmailAddressParts(email.toEmailAddress)[1];
        if (filterEmailAddressDomains.includes(domainPart)) {
            email.status = EmailAddressStatus.FILTER;
            return email;
        }
        const emailAddressIndex = filterEmailAddresses.findIndex(emailAddressItem =>
            textUtils.toLowerCaseTrim(emailAddressItem) === textUtils.toLowerCaseTrim(email.toEmailAddress));
        if (emailAddressIndex > -1) {
            email.status = EmailAddressStatus.FILTER;
            return email;
        }
        for (let i = 0; i < invalidDomains.length; i++) {
            if (domainPart.indexOf(invalidDomains[i]) > -1) {
                email.status = EmailAddressStatus.FILTER;
                return email;
            }
        }
        return email;
    }

    skipDomains(emailsData) {
        const maximumUniqueDomainCount = countsLimitsService.countsLimitsData.maximumUniqueDomainCount;
        if (!maximumUniqueDomainCount || emailsData.emailsList.length <= maximumUniqueDomainCount) {
            return emailsData;
        }
        const emailsDataGroupsList = [];
        const updatedEmailsDataList = [];
        for (let i = 0; i < emailsData.emailsList.length; i++) {
            const emailData = emailsData.emailsList[i];
            const splitResult = textUtils.getEmailAddressParts(emailData.toEmailAddress);
            if (!splitResult || splitResult.length < 2) {
                continue;
            }
            const domainPart = textUtils.toLowerCaseTrim(splitResult[1]);
            if (!domainPart) {
                continue;
            }
            // Check if the domain is common domain. Not relevant is true.
            const isCommonDomain = commonEmailAddressDomainsList.findIndex(domain => domain.domain === domainPart) > -1;
            if (isCommonDomain) {
                updatedEmailsDataList.push(emailData);
                continue;
            }
            const groupIndex = emailsDataGroupsList.findIndex(d => d.domainPart === domainPart);
            // Insert / update the list.
            if (groupIndex > -1) {
                emailsDataGroupsList[groupIndex].emailsList.push(emailData);
            }
            else {
                emailsDataGroupsList.push({
                    domainPart: domainPart,
                    emailsList: [emailData]
                });
            }
        }
        for (let i = 0; i < emailsDataGroupsList.length; i++) {
            const group = emailsDataGroupsList[i];
            let emailsDataGroup = group.emailsList;
            if (emailsDataGroup.length >= maximumUniqueDomainCount) {
                for (let y = 0; y < emailsDataGroup.length; y++) {
                    emailsDataGroup[y].status = EmailAddressStatus.SKIP;
                }
                emailsDataGroupsList[i].emailsList = this.getRandomUniqueKeysFromArray(emailsDataGroup, maximumUniqueDomainCount);
            }
            updatedEmailsDataList.push(...emailsDataGroupsList[i].emailsList);
        }
        emailsData.emailsList = updatedEmailsDataList;
        return emailsData;
    } */

/*     getRandomUniqueKeysFromArray(list, itemsCount) {
        if (list.length === itemsCount) {
            return list;
        }
        const numbersList = [];
        for (let i = 0; i < 20; i++) {
            const number = textUtils.getRandomNumber(0, list.length);
            if (numbersList.indexOf(number) === -1) {
                numbersList.push(number);
                list[number].status = EmailAddressStatus.PENDING;
                if (numbersList.length >= itemsCount) {
                    break;
                }
            }
        }
        return list;
    } */
/*
    addMonitorEmail() {

    }
}

const prepareEmailsService = new PrepareEmailsService();
module.exports = prepareEmailsService; */
/*             debugger; */
/*         // Add template to the email address.
        email = this.addTemplate(email); */
/*     addTemplate(email)
{

} */

// =====================================================

        //emailAddressesList = this.validateEmailAddressesCount(emailAddressesList);
//        //return emailAddressesList;
//console.log(file);
            //console.log(fileName.indexOf(this.sourcesData.emailAddressesIncludeFileName));
/*         if (emailAddressesList.length > 1) {
            emailAddressesList = textUtils.removeDuplicates(emailAddressesList);
        } */
/*         return emailAddressesList; */
/*     getPath() {
        return applicationService.applicationData.isProductionMode ? this.sourcesData.emailAddressesProductionSourcePath :
            this.sourcesData.emailAddressesDevelopmentSourcePath;
    }
 */
/* this.emailAddressesDevelopmentSourcePath = EMAIL_ADDRESSES_DEVELOPMENT_SOURCE_PATH;
this.emailAddressesProductionSourcePath = EMAIL_ADDRESSES_PRODUCTION_SOURCE_PATH; */
/*      this.emailAddressesSourceType = EMAIL_ADDRESSES_SOURCE_TYPE;
     this.emailAddressesSourcePath = EMAIL_ADDRESSES_SOURCE_PATH;
     this.emailAddressesFileName = EMAIL_ADDRESSES_FILE_NAME; */
/*         let path = null;
   if (applicationService.applicationData.isProductionMode)
   {
       path = this.sourcesData.
   }
   return path; */

   /* const countsLimitsService = new CountsLimitsService();
module.exports = countsLimitsService; */

/* const confirmationService = new ConfirmationService();
module.exports = confirmationService; */

/* const applicationService = new ApplicationService();
module.exports = applicationService; */

		// Check if theses paths are in use, if not, remove them.
/* const initiateService = new InitiateService();
module.exports = initiateService; */
/* 'MILLISECONDS_DELAY_MONGO_DATABASE_SYNC_COUNT', */
			// ===UNCHANGED SETTINGS
			//// ===UNCHANGED EMAIL ADDRESS=== //
//const { EmailAddressesSourceType } = require('../../core/enums/files/sources.enum');
//'SECONDARY_BACKUP_PATH',
/* 			// ===LOGS=== //
			// ===BACKUP=== //
			'IS_CREATE_STANDARD_BACKUP', 'IS_CREATE_SECONDARY_BACKUP', */
/* 'SECONDARY_BACKUP_PATH',  */
/* 			// ===MONITOR EMAILS=== // */
			// APPLICATION_NAME, SECONDARY_BACKUP_PATH,
/* 		// ===ROOT PATHS=== //
		settings.SECONDARY_BACKUP_PATH = pathUtils.getJoinPath({ targetPath: SECONDARY_BACKUP_PATH, targetName: APPLICATION_NAME }); */

        		/* Get number from settings.js - 100*/
		/* Get number from settings.js - 100*/
/* const logsService = new LogsService();
module.exports = logsService; */
/* 		let displayToEmailAddress = null;
		let subject = null;
		let text = null; */
/* cSpell:disable */
/*
FULL MESSAGE:
============
Time: 15:05:43 | Code: 200 | Status: SENT/ERROR/EXISTS/DUPLICATE/FILTER/SKIP/INVALID | Step: SEND | Type: Standard/Monitor
From: billyravid83264@gmail.com | To: orassayag@gmail.com | Email Id: 1 | Account Id: 1
Subject (Id: 3): "מציעה עצמי לעבודה בחברתכם" | Text (Id: 4): "שלום רב,"
Result: Sent succesfully / Error: Email address has been blocked / Limit excceeded | Duplicate | Already sent.
============
*/

/* 			fromEmailAddress = textUtils.cutText({ text: sendEmailService.emailData.fromEmailAddress, count: countsLimitsService.countsLimitsData.maximumEmailAddressCharactersDisplayCount });
			toEmailAddress = textUtils.cutText({ text: sendEmailService.emailData.toEmailAddress, count: countsLimitsService.countsLimitsData.maximumEmailAddressCharactersDisplayCount }); */
			//status = sendEmailService.emailAddressStatusKeys.find(key => EmailAddressStatus[key] === sendEmailService.emailData.status);
/* 	createWrapTemplate(isPathExists, original) {
		return isPathExists ? `, ${original}` : original;
	}

	createFixResultTemplate(validationResult, icon) {
		const { original, fix, isValid, functionIds } = validationResult;
		return `${icon ? `${icon} | ` : ''}Time: ${timeUtils.getFullTime()} | isValid: ${isValid} | original: ${original} | fix: ${fix} | functionIds: ${functionIds}`;
	}

	createLineTemplate(title, value) {
		return textUtils.addBreakLine(`${logUtils.logColor(`${title}:`, Color.MAGENTA)} ${value}`);
	} */

/* 		this.sentEmailAddressesPath = null;
		this.errorEmailAddressesPath = null; */
		//this.errorEmailAddressesPath = this.createFilePath(`errors_email_addresses_${Placeholder.DATE}`);
/* EmailAddressStatusKeys,  */
/* LogStatus, */
					//resultDetails =  sendEmailService.emailData.resultDetails.join(' ');
/* 			resultCode = sendEmailService.emailData.resultCode ? sendEmailService.emailData.resultCode : '000'; */
/*
===[SETTINGS] Mode: PRODUCTION | Method: Standard/RandomExceeded | Database: send_production | Drop: false===
===[GENERAL] Time: 00.05:16:58 [-] | Current: 100/500 (31.60%) | Available: 493 | Status: SEND/PAUSE/FINISH/EXCEEDED===
===[PROCESS1] Total: 1,412 | Pending: 500 | Sent: ✅  100 | Error: ❌ 23 | Exists: 11 | Datebase: 24,235===
===[PROCESS2] Save: 100 | Invalid: 0 | Duplicate: 1 | Filter: 22 | Skip: 12 | Unsave: 2 | Identical Addresses: 0===
===[PROCESS3] Monitor Sent: 1 | Security Error: 0 | Security Exists: 0 | Missing Field: 0 | Invalid Status: 0===
===[PROCESS4] Identical Status: 0 | Unexpected Field: 0 | Sent Error In A Row: 0 | Save Error In A Row: 0===
===[ACCOUNT] Id: 4 | Username: billyravid83264@gmail.com | Sent: 59/100 (31.60%) | Accounts: 8/10===
===[API KEY] SG.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX===
===[TEMPLATE] Subject (Id: 3): "מציעה עצמי לעבודה בחברתכם" | Text (Id: 4): "שלום רב,"===
===[ATTACHMENT] C:\\Or\\OrWorld\\Billy Ravid Amit\\CV\\12102020\\CV Billy Ravid.doc===
===[SEND] Code: 202 | Status: SENT/ERROR/EXISTS/DUPLICATE/FILTER/SKIP/INVALID | From: billyravid83264@gmail.com | To: orassayag@gmail.com | Id: 123 | Type: Standard/Monitor===
===[ERROR] Send Error In A Row: 0 | Save Error In a Row: 0===
===[RESULT] Sent successfully / Error: Email address has been blocked / Limit exceeded | Duplicate | Already sent===
*/

/* 	}, {
		[`Subject (Id: ${templatesService.templateData?.subjectId})`]: templatesService.templateData?.subjectDisplay,
		[`Text (Id: ${templatesService.templateData?.textId})`]: templatesService.templateData?.textDisplay
	}, {
		'#': templatesService.cvData?.filePath
	}, { */


/* 		const fromEmailAddress = textUtils.cutText({ text: sendEmailService.emailData?.fromEmailAddress, count: countsLimitsService.countsLimitsData.maximumEmailAddressCharactersDisplayCount });
		const toEmailAddress = textUtils.cutText({ text: sendEmailService.emailData?.toEmailAddress, count: countsLimitsService.countsLimitsData.maximumEmailAddressCharactersDisplayCount }); */

/* 		'Code': sendEmailService.emailData?.resultCode,
		'Result': sendEmailService.emailData?.status,
		'From': fromEmailAddress,
		'To': toEmailAddress,
		'Id': sendEmailService.emailData?.id,
		'Type': sendEmailService.emailData?.type
	}, {
		'#': sendEmailService.emailData?.resultDetails */

/* 		let subjectId = null;
		let textId = null;
		let subjectDisplay = null;
		let textDisplay = null;
		if (templatesService.templateData) {
			subjectId = templatesService.templateData.subjectId;
			textId = templatesService.templateData.textId;
			subjectDisplay = templatesService.templateData.subjectDisplay;
			textDisplay = templatesService.templateData.textDisplay;
		} */
/* 		['IDENTICAL_STATUS', 'identicalStatus'],
		['UNEXPECTED_FIELD', 'unexpectedField'] */
	//console.log(1);

/* 			if (!this.applicationData.startDateTime) {
				this.applicationData.startDateTime = new Date();
				await this.startProcess();
			} */


/* 				applicationData: this.applicationData,
searchProcessData: this.searchProcessData */
/*             // Log the status console each interval round.
			logService.logProgress({
				applicationData: this.applicationData,
				searchProcessData: this.searchProcessData
			}); */
/*         }, this.countsLimitsData.millisecondsIntervalCount);
	}
	} */

	// Rewrite this function with relevant statuses.
/* 	logProgress(logData) {
		const { applicationData, searchProcessData } = logData;
		if (!applicationData || !searchProcessData) {
			return;
		}
		applicationService.applicationData = applicationData;
		this.searchProcessData = searchProcessData;
		const time = `${applicationService.applicationData.time} [${this.frames[this.i = ++this.i % this.frames.length]}]`;
		const steps = textUtils.removeLastCharacterLoop({ text: this.getSteps(), character: ',' });
		const goal = textUtils.replaceCharacter(applicationService.applicationData.goalType, '_', ' ');
		const progress = textUtils.getNumberOfNumber({ number1: applicationService.applicationData.progressValue, number2: applicationService.applicationData.goalValue });
		const percentage = textUtils.calculatePercentageDisplay({ partialValue: applicationService.applicationData.progressValue, totalValue: applicationService.applicationData.goalValue });
		const process = textUtils.getNumberOfNumber({ number1: applicationService.applicationData.processIndex + 1, number2: this.countsLimitsData.maximumSearchProcessesCount });
		const crawlLinks = `${StatusIcon.V}  ${applicationService.applicationData.crawlLinksData.crawlCount}`;
		const saveEmailAddress = `${StatusIcon.V}  ${textUtils.getNumberWithCommas(applicationService.applicationData.crawlEmailAddressesData.saveCount)}`;
		const invalidEmailAddress = `${StatusIcon.X}  ${applicationService.applicationData.crawlEmailAddressesData.invalidCount}`;
		const pageIndex = textUtils.getNumberOfNumber({ number1: applicationService.applicationData.pageIndex + 1, number2: this.countsLimitsData.maximumSearchEnginePagesPerProcessCount });
		const link = applicationService.applicationData.pageLinksCount ?
			textUtils.getNumberOfNumber({ number1: applicationService.applicationData.pageLinksIndex + 1, number2: applicationService.applicationData.pageLinksCount }) : '(-)';
		const trending = textUtils.cutText({ text: applicationService.applicationData.trendingSaveList.join(' | '), count: this.countsLimitsData.maximumConsoleLineCharacters });
		const page = textUtils.cutText({ text: this.searchProcessData.pageLink, count: this.countsLimitsData.maximumConsoleLineCharacters });
		const engine = textUtils.upperCaseFirstLetter(this.searchProcessData.searchEngine.name, 0);
		const userAgent = this.searchProcessData.pageUserAgent ? this.searchProcessData.pageUserAgent : '';
		const search = textUtils.cutText({ text: this.searchProcessData.searchEngineLinkTemplate, count: this.countsLimitsData.maximumConsoleLineCharacters });
		const statistices = textUtils.getObjectKeyValues(applicationService.applicationData.crawlEmailAddressesData.statistics);
		logUtils.logProgress({
			titlesList: ['SETTINGS', 'GENERAL', 'PROCESS', 'LINK', 'EMAIL ADDRESS', `PAGE (${link})`,
				'USER AGENT', `SEARCH (${pageIndex})`, 'TRENDING', 'STATISTICS'],
			colorsTitlesList: [Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE,
			Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE],
			keysLists: [{
				'Mode': applicationService.applicationData.mode,
				'Method': applicationService.applicationData.method,
				'Database': this.mongoDatabaseData.mongoDatabaseModeName,
				'Drop': this.mongoDatabaseData.isDropCollection,
				'Long': applicationService.applicationData.isLongRun,
				'Steps': steps
			}, {
				'Time': time,
				'Goal': goal,
				'Progress': `${progress} (${percentage})`,
				'Status': applicationService.applicationData.status,
				'Restarts': applicationService.applicationData.restartsCount
			}, {
				'Process': process,
				'Page': pageIndex,
				'Engine': engine,
				'Key': this.searchProcessData.displaySearchKey
			}, {
				'Crawl': crawlLinks,
				'Total': applicationService.applicationData.crawlLinksData.totalCount,
				'Filter': applicationService.applicationData.crawlLinksData.filterCount,
				'Error': applicationService.applicationData.crawlLinksData.errorCount,
				'Error In A Row': applicationService.applicationData.errorPageInARowCounter,
				'Current': link
			}, {
				'Save': saveEmailAddress,
				'Total': applicationService.applicationData.crawlEmailAddressesData.totalCount,
				'Database': applicationService.applicationData.crawlEmailAddressesData.databaseCount,
				'Exists': applicationService.applicationData.crawlEmailAddressesData.existsCount,
				'Invalid': invalidEmailAddress,
				'Valid Fix': applicationService.applicationData.crawlEmailAddressesData.validFixCount,
				'Invalid Fix': applicationService.applicationData.crawlEmailAddressesData.invalidFixCount,
				'Unsave': applicationService.applicationData.crawlEmailAddressesData.unsaveCount,
				'Filter': applicationService.applicationData.crawlEmailAddressesData.filterCount,
				'Skip': applicationService.applicationData.crawlEmailAddressesData.skipCount
			}, {
				'#': page
			}, {
				'#': userAgent
			}, {
				'#': search
			}, {
				'#': trending
			}, {
				'#': statistices
			}],
			colorsLists: [
				[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
				[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
				[Color.CYAN, Color.CYAN, Color.CYAN, Color.MAGENTA],
				[Color.GREEN, Color.CYAN, Color.CYAN, Color.RED, Color.RED, Color.CYAN],
				[Color.GREEN, Color.CYAN, Color.CYAN, Color.CYAN, Color.RED, Color.GREEN,
				Color.RED, Color.RED, Color.MAGENTA, Color.YELLOW]
			],
			statusColor: Color.CYAN
		});
	} */

	// Rewrite this function with relevant statuses.
/* 	async logEmailAddress(emailAddressStatus) {
		const { validationResult, logStatus } = emailAddressStatus;
		const { original, fix } = validationResult;
		let path, message = '';
		switch (logStatus) {
			case LogStatus.VALID:
				if (this.logsData.isLogValidEmailAddresses) {
					path = this.emailAddressesPath;
					message = this.createWrapTemplate(await fileUtils.isPathExists(path), fix ? fix : original);
				}
				break;
			case LogStatus.FIX:
				if (this.logsData.isLogFixEmailAddresses && this.isLogFixEmailAddress(validationResult)) {
					path = this.fixedEmailAddressesPath;
					message = textUtils.addBreakLine(this.createFixResultTemplate(validationResult));
				}
				break;
			case LogStatus.INVALID:
				if (this.logsData.isLogInvalidEmailAddresses && this.isLogInvalidEmailAddress(validationResult)) {
					path = this.invalidEmailAddressesPath;
					message = textUtils.addBreakLine(this.createInvalidResultTemplate(validationResult));
				}
				break;
			case LogStatus.UNSAVE:
				if (this.logsData.isLogUnsaveEmailAddresses) {
					path = this.unsaveEmailAddressesPath;
					message = this.createWrapTemplate(await fileUtils.isPathExists(path), original);
				}
				break;
		}
		// In case no log status is relevant to log, don't log anything.
		if (path && message) {
			await fileUtils.appendFile({
				targetPath: path,
				message: message
			});
		}
	} */
/* 		this.pathsData = null;
		this.mongoDatabaseData = null;
		this.searchProcessData = null;
		this.countsLimitsData = null;
		this.pathsData = null; */
/* data */
/* 		const { logsData, applicationData, mongoDatabaseData, countsLimitsData, pathsData } = data;
		this.logsData = logsData;
		this.pathsData = applicationData;
		this.mongoDatabaseData = mongoDatabaseData;
		this.countsLimitsData = countsLimitsData;
		this.pathsData = pathsData; */
/* const { Color } = require('../../core/enums/files/text.enum');
const { LogStatus } = require('../../core/enums/files/emailAddress.enum');
const { StatusIcon } = require('../../core/enums/files/text.enum');
const { Placeholder } = require('../../core/enums/files/placeholder.enum'); */

        //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSimulateDelaySaveProcessCount);
/* const mongoDatabaseService = new MongoDatabaseService();
module.exports = mongoDatabaseService; */
/*                 description: 'Email address saved successfully.\n' */
/*                 description: `Email address not saved.\n${systemUtils.getErrorDetails(error)}\n` */
                                    //description: `Email address not saved.\n${systemUtils.getErrorDetails(error)}\n`
                                    //description: 'Email address saved successfully.\n'
                                    //description: 'Email address not saved.\nValidation of security existence in the Mongo database.\n'
/* const globalUtils = require('../../utils/files/global.utils'); */
                //throw new Error('Test');
        //let status, description = null;
/*     async saveEmailAddress(emailAddress) {
        emailAddress = emailAddress.trim();
        if (await this.isEmailAddressExists(emailAddress)) {
            mongoDatabaseResult.status = EmailAddressStatus.SECURITY_EXISTS;
            mongoDatabaseResult.description = 'Email address not saved.\nValidation of security existence in the Mongo database.\n';
            mongoDatabaseResult.isSave = false;
            return mongoDatabaseService;
        }
        let status, description = null;
        for (let i = 0; i < countsLimitsService.countsLimitsData.maximumSaveEmailAddressesRetriesCount; i++) {
            try {
                await new EmailAddressModel({ emailAddress: emailAddress }).save();
                status = EmailAddressStatus.SAVE;
                description = 'Email address saved successfully.\n';
                break;
            }
            catch (error) {
                status = EmailAddressStatus.UNSAVE;
                description = `Email address not saved.\n${systemUtils.getErrorDetails(error)}\n`;
            }
            finally {
                await globalUtils.sleep(countsLimitsService.countsLimitsData.millisecondsDelayMongoDatabaseSyncCount);
            }
        }
        return {
            status: status,
            description: description,
            isContinueProcess: status === EmailAddressStatus.SAVE
        };
    } */

/*             mongoDatabaseResult.status = EmailAddressStatus.SECURITY_EXISTS;
    mongoDatabaseResult.description = 'Email address not saved.\nValidation of security existence in the Mongo database.\n';
    mongoDatabaseResult.isSave = false;
    return mongoDatabaseService; */

/*         return {
            status: status,
            description: description,
            isContinueProcess: status === EmailAddressStatus.SAVE
        }; */

/*     status = EmailAddressStatus.UNSAVE;
    description = `Email address not saved.\n${systemUtils.getErrorDetails(error)}\n`; */
/*     setSendGridSendResult(sendResult) {
        if (!sendResult) {
          return this.setSendGridErrorResult(null, 'Result object was not found.\n');
        }
        const statusCode = sendResult[0].statusCode;
        const codeData = sendgridUtils.resultCodesList[statusCode];
        if (!codeData) {
          return this.setSendGridErrorResult(null, `CodeData object was not found in the list for status code ${statusCode}.\n`);
        }
        this.getErrorInARowResult(null);
        return new SendGridResult({
          sendError: null,
          code: statusCode,
          reason: codeData.reason,
          description: codeData.description,
          isSent: codeData.isSent,
          exitProgramStatus: null
        });
      }

      setSendGridErrorResult(sendError, errorMessage) {
        let code, reason, description = null;
        if (!sendError) {
          sendError = new Error(errorMessage);
        }
        if (sendError.code) {
          code = sendError.code;
          reason = sendError.message;
          if (sendError.response.body.errors.length > 0) {
            description = sendError.response.body.errors[0].message;
          }
          sendError = null;
        }
        const exitProgramStatus = this.getErrorInARowResult(code ? parseInt(code) : 400); // Bad request code as default for this function.
        return new SendGridResult({
          sendError: sendError,
          code: code,
          reason: reason,
          description: description,
          isSent: false,
          exitProgramStatus: exitProgramStatus
        });
      } */

    //const mongoDatabaseResult = new MongoDatabaseResult();
/*             finally {
            await globalUtils.sleep(countsLimitsService.countsLimitsData.millisecondsDelayMongoDatabaseSyncCount);
        } */

/* status = EmailAddressStatus.SAVE;
description = 'Email address saved successfully.\n'; */

/*             return {
                status: EmailAddressStatus.SECURITY_EXISTS,
                description: 'Email address not saved.\nValidation of security existence in the Mongo database.\n',
                isContinueProcess: false
            }; */

            //return EmailAddressStatus.SECURITY_EXISTS;
/* const { SaveStatus } = require('../../core/enums'); */
/* const sendEmailService = require('') */
        //this.sendEmailsData.addCounter('database', await mongoDatabaseService.getEmailAddressesCount()); */
/* data */
/*         const { mongoDatabaseData } = data;
        this.mongoDatabaseData = mongoDatabaseData; */
/* countsLimitsData,  */
/*         this.countsLimitsData = countsLimitsData; */
/*         this.countsLimitsData = null; */
/*         // Check if the email address exists in the Mongo database.
const emailAddressModel = await EmailAddressModel.findOne({ 'emailAddress': insertEmailAddress });
if (emailAddressModel) {
    return SaveStatus.EXISTS;
} */
//        const insertEmailAddress = emailAddress.trim();
//const { SaveStatus } = require('../../core/enums/files/emailAddress.enum');
/*             finally {
                await globalUtils.sleep(this.countsLimitsData.millisecondsDelayMongoDatabaseSyncCount);
            } */
//        const insertEmailAddress = emailAddress.trim();

/* const pathsService = new PathsService();
module.exports = pathsService; */

            //await mongoDatabaseService.save(this.emailData.toEmailAddress) : await mongoDatabaseService.simulate();
/* const sendEmailService = new SendEmailService();
module.exports = sendEmailService; */
                    //isLog: true,
                        //isLog: true,
/* , isLog */
                //isLog = false;
/*                 isLog = true; */
/*                 isLog: isLog, */
/* , isLog */
/*                 isLog = true; */
        // Log the emailData results.
        //if (isLog) {
            //logService.logResult(this.emailData);
        //}
                // Log result.
/* const logService = require('./logs.service'); */
        //logService.logResult(this.emailData);
    //logResult() { }
        //debugger;
/* , 'retriesCount' */
/*, 'resultCode' */
            //resultDetails: [`Error: break process in the ${stepName} step.\n${extraDetails ? extraDetails : ''}`],
            //resultDetails: `Error: break process in the ${stepName} step.\n${extraDetails ? extraDetails : ''}`,
/*             emailProcessResult.isContinueProcess = this.breakProcess(null, SendEmailStepName.INITIATE, `The email in status of ${this.emailData.status}.\n`); */
/*             emailProcessResult.isContinueProcess = this.breakProcess(EmailAddressStatus.EXISTS, SendEmailStepName.INITIATE, 'Email address exists in the Mongo database.\n'); */
                        //emailProcessResult.isContinueProcess = this.breakProcess(EmailAddressStatus.SECURITY_ERROR, SendEmailStepName.VALIDATE, 'Email addresses already sent in this session.\n');
                //resultDetails = `Identical statuses of ${status}.\n`;
/*                     isContinueProcess = this.breakProcess(EmailAddressStatus.MISSING_FIELD, SendEmailStepName.VALIDATE, `Missing field: ${key}.\n`); */
/*                     isContinueProcess = this.breakProcess(EmailAddressStatus.UNEXPECTED_FIELD, SendEmailStepName.VALIDATE, `Unexpected field: ${key}.\n`); */
/*             return this.breakProcess(EmailAddressStatus.IDENTICAL_ADDRESSES, SendEmailStepName.VALIDATE, 'The from email and the to address identical.\n'); */
/*             return this.breakProcess(EmailAddressStatus.INVALID_STATUS, SendEmailStepName.VALIDATE, `Invalid status ${this.emailData.status} in this step.\n`); */
                                                                    //resultDetails: 'Error: the email was not sent.\nNo sendResult object was found.\n',
                                                //resultDetails = `${description}\n`;
                //resultDetails = 'Error: the email was not sent.\n';
                    //resultDetails += `${systemUtils.getErrorDetails(sendError)}\n`;
                                                            //resultDetails = 'No sendError, reason or description were found.\n';
                    //resultDetails += `Reason: ${reason}\nDescription: ${description}\n`;

        //const saveResult = await mongoDatabaseService.saveEmailAddress(this.emailData.toEmailAddress);
/*
    validateSendResult() { }

    validateSaveResult() { }

    validateAccountStatus() { } */
//        //accountsService.checkAccount(true);
        //debugger;
        //debugger;
//            const isAccountSwitched = accountsService.switchAccount();
/*             default:
break; */
/*         if (status === EmailAddressStatus.SAVE) {
            this.emailData.status = EmailAddressStatus.SENT;
        }
        else {
        } */
/*         // If result exists already, don't override it. Abort the function.
        if (this.emailData.status !== EmailAddressStatus.SECURITY_EXISTS) {
            return;
        } */
        //let isOverridStatus = false;
/*
    status: status,
    description: description,
    isSave: false,
    exitProgramStatus: exitProgramStatus */

        //accountsService.checkAccount(true);
                        //let isContinueProcess = null;
                            //isContinueProcess = false;
                //isContinueProcess = true;
                                //isContinueProcess = false;
/*     async runEmailProcessSend() {
        // Send the email (sendgridService) or simulate email send process (flag from settings.js) + Random SENT/ERROR status.
        const sendResult = await this.send();
        if (!this.sendResultProcess(sendResult)) {
            return false;
        }
        // Insert to securityEmailsSentList.
        this.securityEmailsSentList.push(this.emailData.toEmailAddress);
        // Save the email address in the Mongo database.
        const saveResult = await mongoDatabaseService.saveEmailAddress(this.emailData.toEmailAddress);
        if (!this.saveResultProcess(saveResult)) {
            return false;
        }
        // Log result here.
        return true;
    } */

            //return false;
/*     async runEmailProcess(emailData) {
        this.emailData = emailData;
        // Step 1 - Check status, check if exists in Mongo database, and check account status.
        if (!await this.runEmailProcessInitiate()) {
            return;
        }
        // Step 2 - Security check, add text and subject, and validate all the fields.
        if (!this.runEmailProcessValidate()) {
            return;
        }
        // Step 3 - Send the email, save it to the Mongo database, and log the result.
        if (!await this.runEmailProcessSend()) {
            return;
        }
    } */

/*         // Step 4 - Check account status (for possible accounts switch).
    if (!runEmailProcessFinalize) */
/*     runEmailProcessFinalize() {
        // Check error-in-row for specific error codes / texts.

        // Check error-in-row for saved email address to Mongo database.

        // Check account status / Switch account if needed / Exit if needed.
    } */

        //return false;
//        debugger;
        //this.emailData.resultDateTime = new Date();
    //const { keysList } = data;
/*         const keysFilledList = ['id', 'createDateTime', 'accountId', 'accountApiKey', 'toEmailAddress', 'fromEmailAddress',
    'subjectId', 'subject', 'subjectDisplay', 'textId', 'text', 'textDisplay', 'status', 'type'];
let isContinueProcess = true;
for (let i = 0; i < keysFilledList.length; i++) {
    const key = keysFilledList[i];
    const value = this.emailData[key];
    if (!value) {
        isContinueProcess = this.breakProcess(EmailAddressStatus.MISSING_FIELD, SendEmailStepName.VALIDATE, `Missing field: ${key}.\n`);
        break;
    }
}
if (!isContinueProcess) {
    return false;
} */
/*         const keysEmptyList = ['resultDateTime', 'resultDetails', 'resultCode'];
for (let i = 0; i < keysEmptyList.length; i++) {
const key = keysEmptyList[i];
const value = this.emailData[key];
if (value) {
isContinueProcess = this.breakProcess(EmailAddressStatus.UNEXPECTED_FIELD, SendEmailStepName.VALIDATE, `Unexpected field: ${key}.\n`);
break;
}
} */
/*         if (!isContinueProcess) {
            return false;
        } */

        //debugger;
        //this.emailData.resultDateTime = new Date();
        //console.log(this.emailData);
        //debugger;
/*         debugger; */
        //NOT_EXPECTED_FIELD
                //let isContinueProcess = true;
/*         // Add new status of 'NOT EXPECTED FIELDS' - Check all fields of resultDateTime, resultDetails, resultCode and validate that all of them are null.
        // If not, exit the process and details about it. */
            //this.emailData.status = status;
        //debugger;
//            //this.emailData.status = status;
/*  If they are identical,
            // change the email to status of it as 'IDENTICAL_STATUS'. */
        //this.emailData.status = EmailAddressStatus.INVALID;
        //this.emailData.id = null;
/*     const { id, emailAddress, type } = data;
    this.id = id;
    this.createDateTime = new Date();
    this.accountId = null;
    this.accountApiKey = null;
    this.toEmailAddress = emailAddress;
    this.fromEmailAddress = null;
    this.subjectId = null;
    this.subject = null;
    this.subjectDisplay = null;
    this.textId = null;
    this.text = null;
    this.textDisplay = null;
    this.status = EmailAddressStatus.PENDING;
    this.type = type;
    this.resultDateTime = null;
    this.resultDetails = null;
    this.resultCode = null; */

            //debugger;
/*             status = EmailAddressStatus.ERROR;
resultDetails = 'Error: the email was not sent.\nNo sendResult object was found.\n';
isLog = true; */
                //isContinueProcess = false;
//        debugger;
/*     async send() {
        let sendResult = null;
        if (applicationService.applicationData.isSendEmails) {
            sendResult = await sendgridService.send(this.emailData, templatesService.cvData);
        }
        else {
            sendResult = await sendgridService.simulate();
        }
        return sendResult;
    } */

    //updateSmailsSentList() { }
/*     endProcess(sendResult) {
        const { isSend, sendError } = sendResult;
        let status, resultDetails, isLog = null;
        if (isSend) {
            status = EmailAddressStatus.SENT;
            isLog = false;
        }
        else {
            status = EmailAddressStatus.ERROR;
            resultDetails = `Error: the email was not sent.\n${systemUtils.getErrorDetails(sendError)}`;
            isLog = true;
        }
        this.setProcessResults({
            status: status,
            resultDetails: resultDetails,
            isLog: isLog
        });
        return isSend;
    } */
/* this.emailData */
        //const sendResult = await sendgridService.send(this.emailData, templatesService.cvData);
        //const sendResult = applicationService.applicationData.isSendEmails ? await sendgridService.send(this.emailData, templatesService.cvData)
                // Add simulate email send if flag is false.
//        debugger;
//const { findEmailAddressesRegex } = require('../../utils/files/regex.utils');
    //saveEmail() { }
            //resultDetails = 'Success: the email was sent.';
        //return false;
/*     endProcess(sendResult) {
        const { isSend, sendError } = sendResult;
        this.emailData.resultDateTime = new Date();
        if (isSend) {
            this.emailData.status = EmailAddressStatus.SEND;
            this.emailData.resultDetails = 'Success: the email was sent.';
        }
        else {
            this.emailData.status = EmailAddressStatus.ERROR;
            this.emailData.resultDetails = `Error: the email was not sent.\n${systemUtils.getErrorDetails(sendError)}`;
        }
        this.emailData.status = status;
        this.updateSendEmailsData();
        // Log the emailData results here.
        //return true;
    }

    breakProcess(status, stepName, extraDetails) {
        if (status) {
            this.emailData.status = status;
            this.updateSendEmailsData();
        }
        this.emailData.resultDateTime = new Date();
        this.emailData.resultDetails = `Error: break process in the ${stepName} step.${extraDetails ? ` ${extraDetails}` : ''}`;
        // Log the emailData results here.
        return false;
    } */

/*     endProcess(sendResult) {
        const { isSend, sendError } = sendResult;
        this.emailData.resultDateTime = new Date();
        if (isSend) {
            this.emailData.status = EmailAddressStatus.SEND;
            this.emailData.resultDetails = 'Success: the email was sent.';
        }
        else {
            this.emailData.status = EmailAddressStatus.ERROR;
            this.emailData.resultDetails = `Error: the email was not sent.\n${systemUtils.getErrorDetails(sendError)}`;
        }
        this.emailData.status = status;
        this.updateSendEmailsData();
        // Log the emailData results here.
        return true;
    }

    setResultProcess(data)
    {

    } */

/*     breakProcess(status, stepName, extraDetails) {
        if (status) {
            this.emailData.status = status;
            this.updateSendEmailsData();
        }
        this.emailData.resultDateTime = new Date();
        this.emailData.resultDetails = `Error: break process in the ${stepName} step.${extraDetails ? ` ${extraDetails}` : ''}`;
        // Log the emailData results here.
        return false;
    } */

/*     setSendResult(sendResult) {
const { isSend, sendError } = sendResult;
let status, extraDetails;
if (isSend)
{
status = EmailAddressStatus.SEND;
}
else
{
status = EmailAddressStatus.ERROR;
}
this.breakProcess(status, stepName, extraDetails, sendError);
} */
/* , error */
    //this.emailData.error = error;
        //this.emailData.error = sendError;
//    sendEmail() { }
//        this.emailData.toEmailAddress = this.emailData.fromEmailAddress;
        //this.emailData.status = EmailAddressStatus.INVALID;
/* if (!isContinueProcess) {
    return false;
} */
//                //isBreakProcess = true;
/* 		[
            'id', 'createDateTime', 'accountId', 'toEmailAddress', 'fromEmailAddress', 'subjectId',
            'subject', 'subjectDisplay', 'textId', 'text', 'textDisplay', 'status', 'type'
        ].map(key => {
            const value = this.emailData[key];
            if (!value) {
            }
        }); */
        //throw new Error(`Invalid or no ${key} parameter was found: Excpected a string but received: ${value} (1000038)`);
/*         const { id, emailAddress, type } = data;
        this.id = id;
        this.createDateTime = new Date();
        this.accountId = null;
        this.toEmailAddress = emailAddress;
        this.fromEmailAddress = null;
        this.subjectId = null;
        this.subject = null;
        this.subjectDisplay = null;
        this.textId = null;
        this.text = null;
        this.textDisplay = null;
        this.status = EmailAddressStatus.PENDING;
        this.type = type;
        this.isSaved = false;
        this.resultDateTime = null;
        this.resultDetails = null;
        this.error = null;
         */
/*         if (!this.emailData.id) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: id');
        }
        if (!this.emailData.createDateTime) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: createDateTime');
        }
        if (!this.emailData.accountId) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: accountId');
        }
        if (!this.emailData.toEmailAddress) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: toEmailAddress');
        }
        if (!this.emailData.fromEmailAddress) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: fromEmailAddress');
        }
        if (!this.emailData.subjectId) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: subjectId');
        }
        if (!this.emailData.subjectId) {
            return this.breakProcess(EmailAddressStatus.MISSING, SendEmailStepName.VALIDATE, 'Missing field: subjectId');
        } */

        //this.emailData.error = error;
/*         this.subjectId = subject.id,
        this.subject = subject.subject;
        this.subjectDisplay = subject.subjectDisplay;
        this.textId = text.id,
        this.text = text.text;
        this.textDisplay = text.textDisplay; */
/*     setEmailTemplate()
    {

    }
 */

/*     getTemplate() { } */
//        debugger;
//'test1@example.com'
/*  console.log(this.emailData); */
//emailData
/* this.emailData */
//    securityValidation() { }
/*             this.updateSendEmailsData(this.emailData);
        return false; */

/*             this.emailData.status = EmailAddressStatus.EXISTS;
this.updateSendEmailsData(this.emailData);
return false; */

/*             this.emailData.status = EmailAddressStatus.SECURITY_ERROR;
this.updateSendEmailsData(this.emailData);
return false; */

/*         let isContinueProcess = true; */

/*     isContinueProcess = await this.runEmailProcessInitiate();
    if (!isContinueProcess) {
        return;
    } */
/*         isContinueProcess = await this.runEmailProcessInitiate();
 */

/*
    // Get the account that will send the email.
    const checkAccountResult = accountsService.checkAccount({
        isIncrement: false,
        accountData: accountData,
        accountsData: accountsData
    });
    return this.createInitateResult({
        emailData: emailData,
        sendEmailsData: sendEmailsData,
        accountData: accountData,
        accountsData: accountsData
    }, false);
    return sendEmailInitiateResult; */

/*     // Validate that the email address not exists in the Mongo database.
if (await mongoDatabaseService.isEmailAddressExists(emailData.toEmailAddress)) {
emailData.status = EmailAddressStatus.EXISTS;
return this.createInitateResult({
    emailData: emailData,
    sendEmailsData: sendEmailsData,
    accountData: accountData,
    accountsData: accountsData
}, false);
} */

    //SendEmailInitiateResult
    //return this.createInitateResult(data, false);
/*     const { emailData, sendEmailsData } = data;
    return sendEmailsData;
 */
/*     const EmailAddressStatus = enumUtils.createEnum([
['PENDING', 'pending'],
['SAVED', 'saved'],
['SENT', 'sent'],
['ERROR', 'error'],
['EXISTS', 'exists'],
['INVALID', 'invalid'],
['DUPLICATE', 'duplicate'],
['FILTER', 'filter'],
['SKIP', 'skip'],
['UNSAVE', 'sent'],
['IDENTICAL', 'identical'],
['SECURITY_ERROR', 'security_error'],
['SECURITY_EXISTS', 'security_exists']
    ]);
     */
    //const { accountsData } = data;
/*             sendEmailResult.emailData = emailData; */
/*         sendEmailInitiateResult.
        sendEmailInitiateResult.accountData = updatedAccountData.accountData;
        sendEmailInitiateResult.accountsData = updatedAccountData.accountsData; */

/*         const checkAccountResult = accountsService.checkAccount({
    isIncrement: false,
    accountData: accountData,
    accountsData: accountsData
}); */
/* emailData */
/*         const sendEmailInitiateResult = new SendEmailInitiateResult(); */
/*             sendEmailInitiateResult.emailData = emailData;
        return sendEmailInitiateResult; */

/*     async runEmailProcessInitiate(data) {
        const { emailData, sendEmailsData, accountData, accountsData } = data;
        // Validate that the email's status still relevant to be send (if still in pending status).
        if (emailData.status !== EmailAddressStatus.PENDING) {
            return this.createInitateResult(data, false);
        }
        // Validate that the email address not exists in the Mongo database.
        if (await mongoDatabaseService.isEmailAddressExists(emailData.toEmailAddress)) {
            emailData.status = EmailAddressStatus.EXISTS;
            return this.createInitateResult({
                emailData: emailData,
                sendEmailsData: sendEmailsData,
                accountData: accountData,
                accountsData: accountsData
            }, false);
        }
        // Get the account that will send the email.
        const checkAccountResult = accountsService.checkAccount({
            isIncrement: false,
            accountData: accountData,
            accountsData: accountsData
        });
        return this.createInitateResult({
            emailData: emailData,
            sendEmailsData: sendEmailsData,
            accountData: accountData,
            accountsData: accountsData
        }, false);
        return sendEmailInitiateResult;
    }

    createInitateResult(data, isNoAccountsLeft) {
        const { emailData, accountData, accountsData } = data;
        let { sendEmailsData } = data;
        const sendEmailInitiateResult = new SendEmailInitiateResult();
        sendEmailsData = this.checkEmailStatus({
            emailData: emailData,
            sendEmailsData: sendEmailsData
        });
        sendEmailInitiateResult.emailData = emailData;
        sendEmailInitiateResult.isNoAccountsLeft = isNoAccountsLeft;
        sendEmailInitiateResult.sendEmailsData = sendEmailsData;
        sendEmailInitiateResult.accountData = accountData;
        sendEmailInitiateResult.accountsData = accountsData;
        return sendEmailInitiateResult;
    }

/*     async runEmailProcessInitiate() {
    }
 */

        // Return final result.
//(If not simulate send email) |
/*     validateMongoDatabaseExists() { } */

/*     this.accountData = null;
    getAccount() {
        if (!this.accountData)
        {

        }
    } */

/*         // Get the account that will send the email.
    emailData = this.getAccount(emailData); */
         // Check if from and to identical.
        // (If not simulate send email) | Check account status / Switch account if needed / Exit if needed.

            // make the 400 as global parameter.
    /*  400 */
    /* systemUtils, */
    //await systemUtils.pause(countsLimitsService.countsLimitsData.millisecondsSimulateDelaySendProcessCount);
/* const sendgridService = new SendGridService();
module.exports = sendgridService; */
                    //resolve(this.setSendGridErrorResult(null, 'Send email process exceeded timeout limit.\n'));
                    //return this.setSendGridErrorResult(null, 'Result object was not found.\n');
/* return this.setSendGridErrorResult(null, `CodeData object was not found in the list for status code ${statusCode}.\n`); */
//    debugger;
      //const code = 429;
//    debugger;
//   debugger;
        //throw new Error('test');
      //console.log(codeData);
        //debugger;
//        //throw new Error('test');
/* Error: Unauthorized\n    at C:\\Or\\Web\\Sender\\Sender\\node_modules\\@sendgrid\\client\\src\\classes\\client.js:145:29\n    at processTicksAndRejections (internal/process/task_queues.js:93:5) {code: 401, message: 'Unauthorized', response: {…}, stack: 'Error: Unauthorized\n    at C:\\Or\\Web\\Sender\\S (internal/process/task_queues.js:93:5)'}
code:401
message:'Unauthorized'
response:{headers: {…}, body: {…}}
body:{errors: Array(1)}
errors:(1) [{…}]
0:{message: 'The provided authorization grant is invalid, expired, or revoked', field: null, help: null}
field:null
help:null
message:'The provided authorization grant is invalid, expired, or revoked'
__proto__:Object
length:1
__proto__:Array(0)
__proto__:Object
headers:{server: 'nginx', date: 'Sat, 21 Nov 2020 15:32:04 GMT', content-type: 'application/json', content-length: '116', connection: 'close', …}
__proto__:Object
stack:'Error: Unauthorized\n    at C:\\Or\\Web\\Sender\\Sender\\node_modules\\@sendgrid\\client\\src\\classes\\client.js:145:29\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)'
__proto__:Error */

/*     if (!(sendError instanceof Error)) {

    } */

//        debugger;
      //debugger;
                      //debugger;
        //debugger;
              //debugger;
              //debugger;
              //sendError = error;
/*       resolve(this.setSendGridResult({
        sendResult: sendResult,
        sendError: sendError
      } */

              //resolve(sendgridResult);
/*       // Send the email.
      let sendResult, sendError = null;
      try {
        sendResult = await sgMail.send(email);
      }
      catch (error) {
        sendError = error;
      }
      clearTimeout(abortTimeout);
      resolve(this.setSendGridResult({
        sendResult: sendResult,
        sendError: sendError
      })); */
/*   setSendGridCodeNotFoundResult() {
  return new SendGridResult({
    sendError: new Error('Result object was not found'),
    code: null,
    reason: null,
    description: null,
    isSent: null
  });
}

setSendGridCodeNotFoundCode(code) {

}

setSendGridTimeoutResult() {

} */

/*   setSendGridResult(data) {
const { sendResult, sendError } = data;
if (!sendResult || sendError)
{
}
const sendgridResult = new SendGridResult();
const codeData = sendgridUtils.resultCodesList[sendResult[0].statusCode];
if (!codeData)
{

}
return sendgridResult;
}

setSendGridTimeoutResult()
{
const sendgridResult = new SendGridResult();
return sendgridResult;
} */

/*         try {
result = await sgMail.send(email);
//console.log(2);
} catch (error) {
isSend = false;
sendError = error;
}
return {
isSend: isSend,
sendError: sendError
}; */

/*         [
          Response {
            statusCode: 202,
            body: '',
              server: 'nginx',
              date: 'Fri, 20 Nov 2020 19:11:20 GMT',
              'content-length': '0',
              connection: 'close',
              'x-message-id': 'gO5i75M3RkiQrkAKx3mIuw',
              'access-control-allow-origin': 'https://sendgrid.api-docs.io',
              'access-control-allow-methods': 'POST',
              'access-control-allow-headers': 'Authorization, Content-Type, On-behalf-of, x-sg-acl',
              'access-control-max-age': '600',
              'x-no-cors-reason': 'https://sendgrid.com/docs/Classroom/Basics/API/cors.html'
            }
          },
          ''
        ] */

/*           console.log('=============error=============');
          console.log(error); */
/*         console.log('=============result=============');
console.log(result); */
                //console.log(1);
//const templatesService = require('./templates.service');
 //templatesService.cvData;
//const { EmailAddressStatus } = require('../../core/enums');
        //emailData.status = isError ? EmailAddressStatus.ERROR : EmailAddressStatus.SENT;
/* return {
    emailData: emailData,
    isBreakSession *///: isBreakSession;
//}
        //let isBreakSession = false;
//        return emailData;
            //this.setResult(error);
/*         const { emailData } = data;
        const { } = emailData; */

/* cSpell:disable */
/* const fs = require('fs');
const sgMail = require('@sendgrid/mail');
require('../services/files/initiate.service').initiate();

// Simulate wait if needed: await this.wait(120000);
const sleep = (milliseconds) => new Promise(resolve => setTimeout(resolve, milliseconds));

(async () => {
  const list = [{
    address: 'billybillyravid@gmail.com',
    key: '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'
  }, {
    address: 'billy.ravid3286623@gmail.com',
    key: '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'
  }];
  for (let i = 0; i < list.length; i++) {
    sgMail.setApiKey(list[i].key);
    const pathToAttachment = `C:\\Or\\OrWorld\\Billy Ravid Amit\\CV\\12102020\\CV Billy Ravid.doc`;
    const attachment = fs.readFileSync(pathToAttachment).toString('base64');
    const msg = {
      to: 'yardenushpozot@gmail.com',
      from: list[i].address,
      subject: 'מציעה את עצמי לעבוד בארגונכם',
      text:
        `שלום רב,
שמי בילי רביד
אני מתעניינת בתחומי הניהול, בכוח אדם, ניהול משרד, ניהול קליניקה רפואית בפועל על כל המשתמע, אדמיניסטרציה, פרוייקטים, תפעול.
בעלת כישורים וניסיון רב בשלל תחומים הקשורים לתחומי המשרות הנ"ל. מחפשת מקום שיהיה לי לבית שני, תחושת משפחתיות ואכפתיות ביחד
עם עבודה אפקטיבית ויעילה.
מצ"ב קורות חיים
תודה ויום נעים.`,
      attachments: [
        {
          content: attachment,
          filename: 'CV Billy Ravid.doc',
          type: 'application/doc',
          disposition: 'attachment'
        }
      ]
    };

    try {
      await sgMail.send(msg);
      console.log('sent!');
    } catch (err) {
      console.error(err.toString());
    }
    await sleep(1000);
  }
})(); */
/* sgMail.send(msg).catch(err => {
  console.log(err);
});
 */

 /* const templatesService = new TemplatesService();
module.exports = templatesService; */
//        //this.templatesData.docCVFile = docCVFile;
/* , TitleData */
/*         this.lastTitleId = 0; */

/*     initiateTemplates() {
        if (templates.length <= 0) {
            throw new Error('No templates found in the templates.json file. (1000014)');
        }
        this.templatesData = new TemplatesData();
        for (let i = 0; i < templates.length; i++) {
            const { title, text } = templates[i];
            if (title) {
                this.lastTitleId++;
                this.templatesData.titlesList.push(new TitleData({
                    id: this.lastTitleId,
                    title: title,
                    titleDisplay: this.getDisplayTemplate(title)
                }));
            }
            if (text) {
                this.lastTextId++;
                this.templatesData.textsList.push(new TextData({
                    id: this.lastTextId,
                    text: text.join('\n'),
                    textDisplay: this.getDisplayTemplate(text[0])
                }));
            }
        }
        if (this.templatesData.titlesList.length <= 0) {
            throw new Error('No titles found in the templates.json file. (1000014)');
        }
        if (this.templatesData.textsList.length <= 0) {
            throw new Error('No texts found in the templates.json file. (1000014)');
        }
    } */

/*     getRandomTitle() {
        let randomTitleId = -1;
        if (!this.templateData?.titleId) {
            randomTitleId = textUtils.getRandomNumber(1, this.templatesData.titlesList.length);
        }
        else {
            for (let i = 0; i < 20; i++) {
                randomTitleId = textUtils.getRandomNumber(1, this.templatesData.titlesList.length);
                if (this.templateData.titleId != randomTitleId) {
                    break;
                }
            }
        }
        return this.templatesData.titlesList.find(t => t.id === randomTitleId);
    } */

    /*     getTemplate() {
        let title, text = null;
        if (this.templatesData.titlesList.length === 1) {
            title = this.templatesData.titlesList[0];
        }
        else {
            title = this.getRandomTitle();
        }
        if (this.templatesData.textsList.length === 1) {
            text = this.templatesData.textsList[0];
        }
        else {
            text = this.getRandomText();
        }
        this.templateData = new TemplateData({
            title: title,
            text: text
        });
    } */

                    //textFirstLine: text[0]
/*         if (!this.templateData) {
            this.getTemplate();
            return;
        } */
            /* const { SourceType } = require('../../core/enums'); */
/*             title = this.getRandomData(SourceType.TITLE); */
        //this.templatesData.docCVFile = docCVFile;
//        const docCVFile = await this.initiateCVFile();
//        //return docCVFile;
//this.templatesData =
//const textUtils = require('../../utils/files/text.utils');
            //this.templatesData.titlesList.push(title);
/*             this.templatesData.textsList.push(new TextData({
                text: text.join('\n'),
                textFirstLine: text[0]
            })); */
/*             this.templatesData.templatesDataList.push(new TemplateData({

            })); */
            //this.templatesData.titlesList.push(title);

/*             this.templatesData.textsList.push(new TextData({
                text: text.join('\n'),
                textFirstLine: text[0]
            })); */
/*         let titleCount, textCount = 0; */
///* , TextData */
            //return templatesData;
/*     initiateTemplates() {
        if (templates.length <= 0) {
            throw new Error('No templates found in the templates.json file. (1000014)');
        }
        const templatesData = new TemplatesData();
        for (let i = 0; i < templates.length; i++) {
            const { title, text } = templates[i];
            templatesData.titlesList.push(title);
            templatesData.textsList.push(new TextData({
                text: text.join('\n'),
                textFirstLine: text[0]
            }));
        }
        if (templatesData.titlesList.length <= 0) {
            throw new Error('No titles found in the templates.json file. (1000014)');
        }
        if (templatesData.textsList.length <= 0) {
            throw new Error('No texts found in the templates.json file. (1000014)');
        }
        return templatesData;
    } */

        //return templatesData;
//const docCVFile = require('../../../misc/data/cv/CV Billy Ravid.doc');
        //this.templatesData = templatesData;
/*         this.docCVFile = docCVFile; */
/*         this.templatesData = null; */

/* const validationService = new ValidationService();
module.exports = validationService; */
/*         const isConnected = await validationService.validateInternetConnection(); */

// Change this in the end to 100.
/*     // Determine the milliseconds count between each action (check if exists and insert)
    // within the Mongo database.
    MILLISECONDS_DELAY_MONGO_DATABASE_SYNC_COUNT: 10, */
//const { EmailAddressesSourceType } = require('../core/enums/files/sources.enum');
/*     // Determine if to do a normal backup to the backups directory.
    IS_CREATE_STANDARD_BACKUP: true,
    // Determine if to do a secondary copy backup to another projects directory.
    IS_CREATE_SECONDARY_BACKUP: false, */
/*
    // ===LOGS=== // */
/*     // Determine the path for the directory of which a secondary backup will be created.
// (Working example: 'G:\\Or\\Web\\Sender').
SECONDARY_BACKUP_PATH: 'G:/Or/Web/Sender', */


/* var myString = 'Hello ';
myString += 'World';
myString += '!';
console.log(myString); */
/* cSpell:disable */
//const fs = require('fs');
//const sgMail = require('@sendgrid/mail');
//require('../services/files/initiate.service').initiate();

// Simulate wait if needed: await this.wait(120000);
//const sleep = (milliseconds) => new Promise(resolve => setTimeout(resolve, milliseconds));
//debugger;
//sgMail.setApiKey('SG.SG7iS4VOQja-ZlRbWK8JPA.xTuMx3ltsp0l621-o1d8QC3c-fWMNzHy7_rjlIWmLr0-%');
//console.log();

/* const sgMail = require('@sendgrid/mail');
(async () => {
    sgMail.setApiKey('SG.SG7iS4VOQja-ZlRbWK8JPA.xTuMx3ltsp0l621-o1d8QC3c-fWMNzHy7_rjlIWmLrsadfsda0');
    const pathToAttachment = `C:\\Or\\OrWorld\\Billy Ravid Amit\\CV\\12102020\\CV Billy Ravid.doc`;
    const attachment = fs.readFileSync(pathToAttachment).toString('base64');
    const msg = {
        to: 'myemail@gmail.com',
        from: 'youremail@gmail.com',
        subject: 'test',
        text: 'test',
/*         attachments: [
            {
              content: attachment,
              filename: 'CV Billy Ravid.doc',
              type: 'application/doc',
              disposition: 'attachment'
            }
          ] */
/*     };
    let result = null;
    try {
        result = await sgMail.send(msg);
        console.log('sent!');
    } catch (err) {
        console.error(err.toString());
    }
    console.log(`result: ${result}`);
})(); */

/* require('../services/files/initiate.service').initiate();

(async () => {


})(); */
/* const { timeUtils } = require('../utils');
const date = new Date();
console.log(timeUtils.getFullDateTime(date)); */

/* const applicationUtils = new ApplicationUtils();
module.exports = applicationUtils; */
//const textUtils = require('../files/text.utils');
//const { Mode } = require('../../core/enums/files/system.enum');
/*     getEmailAddresses(list, maximumCount)
    {
        // Validate email addresses.
            if (!validationUtils.validateEmailAddress(email.toEmailAddress)) {
                email.status = EmailAddressStatus.INVALID;
            }
            return email;
    }

    getRandomUniqueKeysFromArray(list, itemsCount) {
        if (list.length === itemsCount) {
            return list;
        }
        const numbersList = [];
        for (let i = 0; i < 20; i++) {
            const number = textUtils.getRandomNumber(0, list.length);
            if (numbersList.indexOf(number) === -1) {
                numbersList.push(number);
                if (numbersList.length >= itemsCount) {
                    break;
                }
            }
        }
        return list;
    } */
/*                 list[number].status = EmailAddressStatus.INITIATE; */

/* const colorUtils = new ColorUtils();
module.exports = colorUtils; */
/* const { ColorCode } = require('../../core/enums/files/text.enum'); */

/* const fileUtils = new FileUtils();
module.exports = fileUtils; */
    /*     var fs = require('fs');

// Use statSync() method to store the returned
// instance into variable named stats
var stats = fs.statSync("/Users/divyarani/Documents/geekforgeeks/geeks.js");

// Use isFile() method to log the result to screen
console.log('is file ? ' + stats.isFile());

var stats = fs.statSync("/Users/divyarani/Documents/geekforgeeks/geek");

// Use isDirectory() method to log the result to screen
console.log('is directory ? ' + stats.isDirectory());  */

/* const globalUtils = new GlobalUtils();
module.exports = globalUtils; */

/* const logUtils = new LogUtils();
module.exports = logUtils; */
/* const { Color } = require('../../core/enums/files/text.enum'); */

/* const mongoDatabaseUtils = new MongoDatabaseUtils();
module.exports = mongoDatabaseUtils; */

    /*     // This method check if a given file is in a given extension.
        isTypeFile(data) {
            const { fileName, fileExtension } = data;
            // Check if the fileName parameter was received.
            if (!fileName) {
                throw new Error(`fileName not received: ${fileName} (1000032)`);
            }
            // Check if the fileExtension parameter was received.
            if (!fileExtension) {
                throw new Error(`fileExtension not received: ${fileExtension} (1000033)`);
            }
            const extension = path.extname(fileName);
            // Check if the extension parameter was received.
            if (!extension) {
                throw new Error(`extension not received: ${extension} (1000034)`);
            }
            return textUtils.toLowerCase(extension) === textUtils.addStartDot(textUtils.toLowerCase(fileExtension));
        }*/
/* const pathUtils = new PathUtils();
module.exports = pathUtils; */

/* const regexUtils = new RegexUtils();
module.exports = regexUtils; */

/* const sendgridUtils = new SendGridUtils();
module.exports = sendgridUtils; */
        //console.log(this.limitExceededCode);
/* initiate() {
    this.sentCodesList = [];
    this.errorCodesList = [];
    const keys = Object.keys(this.resultCodesList);
    for (let i = 0; i < keys.length; i++) {
        if (i < 2) {
            this.sentCodesList.push(keys[i]);
        }
        else {
            this.errorCodesList.push(keys[i]);
        }
    }
} */
        //console.log(SendGridReason.SERVICE_NOT_AVAILABLE);
        //console.log(SendGridReason);
/*         console.log(this.sentCodesList);
        console.log(this.errorCodesList); */
/* 2xx	2xx responses indicate a successful request	The request that you made is valid and successful.
200	OK	Your message is valid, but it is not queued to be delivered. †
202	ACCEPTED	Your message is both valid, and queued to be delivered.
4xx	4xx responses indicate an error with the request	There was a problem with your request.
400	BAD REQUEST
401	UNAUTHORIZED	You do not have authorization to make the request.
403	FORBIDDEN
404	NOT FOUND	The resource you tried to locate could not be found or does not exist.
405	METHOD NOT ALLOWED
413	PAYLOAD TOO LARGE	The JSON payload you have included in your request is too large.
415	UNSUPPORTED MEDIA TYPE
429	TOO MANY REQUESTS	The number of requests you have made exceeds SendGrid’s rate limitations
5xx	5xx responses indicate an error made by SendGrid	An error occurred when SendGrid attempted to processes it.
500	SERVER UNAVAILABLE	An error occurred on a SendGrid server.
503	SERVICE NOT AVAILABLE	The SendGrid v3 Web API is not available. */

/* const systemUtils = new SystemUtils();
module.exports = systemUtils; */
/*     pause(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    } */

        /*     getRandomUniqueKeysFromArray(list, itemsCount) {
        if (list.length === itemsCount) {
            return list;
        }
        const numbersList = [];
        for (let i = 0; i < 20; i++) {
            const number = this.getRandomNumber(0, list.length);
            if (numbersList.indexOf(number) === -1) {
                numbersList.push(number);
                if (numbersList.length >= itemsCount) {
                    break;
                }
            }
        }
        return numbersList;
    } */

/*     removeDuplicates(list) {
        if (!validationUtils.isExists(list)) {
            return [];
        }
        return Array.from(new Set(list));
    } */

/*     cutText(data) {
        const { text, count } = data;
        if (!text) {
            return '';
        }
        return text.substring(0, count);
    }

    upperCaseFirstLetter(text, index) {
        return index === 0 ? this.toUpperCase(text.slice(0, 1)).concat(text.slice(1)) : text;
    }

    // This method creates a file name.
    createFileName(data) {
        const { fileName, fileKeyName, fileTXTName, isMBOX } = data;
        if (!fileName) {
            return '';
        }
        return `${fileName}${fileKeyName ? `_${fileKeyName}` : ''}${fileTXTName !== null ? `_${fileTXTName}` : ''}${isMBOX ? '' : '.txt'}`;
    }

    verifyCharactersLength(data) {
        const { value, maximumCharactersLength } = data;
        if (!value || !validationUtils.isValidNumber(maximumCharactersLength)) {
            return '';
        }
        return value.length > maximumCharactersLength ? value.substring(0, maximumCharactersLength) : value;
    }

    countDuplicateStrings(list) {
        if (!validationUtils.isExists(list)) {
            return 0;
        }
        return list.filter((item, index) => list.indexOf(item) != index).length;
    }

    isCharacterALetter(character) {
        return regexUtils.detectLetter.test(character);
    }

    addBreakLine(text) {
        return `${text}\r\n`;
    }

    addSpaceLines(text) {
        return `${text}\r\n=======\r\n`;
    }

    checkExistence(list, target) {
        if (!validationUtils.isExists(list)) {
            return false;
        }
        return list.filter(t => target.indexOf(t) > -1).length > 0;
    }

    removeDuplicates(list) {
        if (!validationUtils.isExists(list)) {
            return [];
        }
        return Array.from(new Set(list));
    }

    removeString(data) {
        const { removeText } = data;
        let { text } = data;
        if (!validationUtils.isExists(text) || !validationUtils.isExists(removeText)) {
            return '';
        }
        if (text.indexOf(removeText) > -1) {
            text = text.split(removeText).join('');
        }
        return text;
    }

    replaceContainString(data) {
        const { targetText, replaceText } = data;
        let { text } = data;
        if (!validationUtils.isExists(text) || !validationUtils.isExists(targetText) || !validationUtils.isExists(replaceText)) {
            return '';
        }
        if (text.indexOf(targetText) > -1) {
            text = text.split(targetText).join(replaceText);
        }
        return text;
    }

    replaceAt(data) {
        const { text, position, newText } = data;
        if (!text) {
            return '';
        }
        return [text.substr(0, position), newText, text.substr(position + 1)].join('');
    }

    removeEmptySpaces(text) {
        if (!text) {
            return '';
        }
        return text.replace(regexUtils.cleanSpacesRegex, '');
    }

    removeFirstCharacter(text) {
        if (!text) {
            return '';
        }
        return text.substr(1);
    }

    removeLastCharacter(text) {
        if (!text) {
            return '';
        }
        return text.substring(0, text.length - 1);
    }

    getSplitDotParts(text) {
        if (!text) {
            return '';
        }
        return text.split('.');
    }

    replaceCharacter(text, origin, target) {
        if (!text) {
            return '';
        }
        return text.replace(regexUtils.createRegex(origin), target);
    }

    toUpperCase(text) {
        if (!text) {
            return '';
        }
        return text.toUpperCase();
    }

    sliceJoinDots(array, number) {
        return array.slice(number).join('.');
    }

    addMiddleDot(text1, text2) {
        return `${text1}.${text2}`;
    }

    replaceLast(text, charecter, replace) {
        const a = text.split('');
        a[text.lastIndexOf(charecter)] = replace;
        return a.join('');
    }

    getObjectKeyValues(obj) {
        let result = '';
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = obj[key];
            result += `${this.upperCaseFirstLetter(key, 0)}: ${value} | `;
        }
        result = textUtils.removeLastCharacters({
            value: result,
            charactersCount: 3
        });
        return result;
    } */
/* const textUtils = new TextUtils();
module.exports = textUtils; */
//console.log(percentage);

/* const validationUtils = new ValidationUtils();
module.exports = validationUtils; */

        //this.isNoAccountsLeft = false;
//        this.activeAccount = null;

//        this.titlesList = [];
//        this.templatesDataList = [];

//const timeUtils = new TimeUtils();
//module.exports = timeUtils;